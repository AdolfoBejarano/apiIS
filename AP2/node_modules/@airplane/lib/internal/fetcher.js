"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRetryAfter = exports.isJSONResponse = exports.defaultRetryDelay = exports.Fetcher = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const uuid_1 = require("uuid");
const http_error_1 = require("./http_error");
const set_timeout_1 = require("./set_timeout");
// Fetcher is a wrapper around node-fetch with reasonable defaults that understands the Airplane API format.
class Fetcher {
    constructor(opts) {
        if (!opts.host) {
            throw new Error("expected an api host");
        }
        if (opts.token && opts.apiKey) {
            throw new Error("expected a single authentication method");
        }
        if (!opts.clientKind) {
            throw new Error("expected a client kind");
        }
        if (!opts.clientVersion) {
            throw new Error("expected a client version");
        }
        this.opts = opts;
        const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
        if (isNode) {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const HttpAgent = require("agentkeepalive");
            const HttpsAgent = HttpAgent.HttpsAgent;
            this.httpAgent = new HttpAgent({ keepAlive: true });
            this.httpsAgent = new HttpsAgent({ keepAlive: true });
        }
    }
    async get(path, queryParams, opts = {}) {
        return this.request(path, "GET", {
            ...opts,
            queryParams,
        });
    }
    async post(path, body, opts = {}) {
        return this.request(path, "POST", {
            ...opts,
            body,
        });
    }
    async put(path, body, opts = {}) {
        return this.request(path, "PUT", {
            ...opts,
            body,
        });
    }
    async patch(path, body, opts = {}) {
        return this.request(path, "PATCH", {
            ...opts,
            body,
        });
    }
    async delete(path, body, opts = {}) {
        return this.request(path, "DELETE", {
            ...opts,
            body,
        });
    }
    async request(path, method, opts = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const url = new URL(path, (_a = opts.host) !== null && _a !== void 0 ? _a : this.opts.host);
        // Query parameters can be passed via `opts.queryParams` or directly on `path`.
        for (const [key, value] of Object.entries((_b = opts.queryParams) !== null && _b !== void 0 ? _b : {})) {
            const values = Array.isArray(value) ? value : [value];
            for (const v of values) {
                if (v) {
                    url.searchParams.append(key, v);
                }
            }
        }
        const headers = {};
        for (const [k, v] of Object.entries((_c = this.opts.headers) !== null && _c !== void 0 ? _c : {})) {
            // Do not set headers if their value is an empty string, null, or undefined.
            if (v) {
                headers[k] = v;
            }
        }
        for (const [k, v] of Object.entries((_d = opts.headers) !== null && _d !== void 0 ? _d : {})) {
            // Do not set headers if their value is an empty string, null, or undefined.
            if (v) {
                headers[k] = v;
            }
        }
        headers["X-Airplane-Client-Kind"] = this.opts.clientKind;
        headers["X-Airplane-Client-Version"] = this.opts.clientVersion;
        const idempotencyKey = opts.idempotencyKey || ((_e = opts.headers) === null || _e === void 0 ? void 0 : _e["Idempotency-Key"]) || (0, uuid_1.v4)();
        headers["Idempotency-Key"] = idempotencyKey;
        headers["Accept"] = "application/json";
        if (method !== "GET" && opts.body) {
            headers["Content-Type"] = "application/json";
        }
        if (this.opts.teamID) {
            headers["X-Team-ID"] = this.opts.teamID;
        }
        if (this.opts.token) {
            headers["X-Airplane-Token"] = this.opts.token;
        }
        if (this.opts.apiKey) {
            headers["X-Airplane-API-Key"] = this.opts.apiKey;
        }
        if (this.opts.envID) {
            headers["X-Airplane-Env-ID"] = this.opts.envID;
        }
        if (this.opts.envSlug) {
            headers["X-Airplane-Env-Slug"] = this.opts.envSlug;
        }
        if (this.opts.source) {
            headers["X-Airplane-Client-Source"] = this.opts.source;
        }
        // Used in Studio only. If an ngrok tunnel token is provided, we need to set the following
        // header so that the dev server accepts the request.
        if (this.opts.tunnelToken) {
            headers["X-Airplane-Dev-Token"] = this.opts.tunnelToken;
        }
        // If a sandbox token is provided, we need to set the following header so that the sandbox
        // router accepts the request.
        if (this.opts.sandboxToken) {
            headers["X-Airplane-Sandbox-Token"] = this.opts.sandboxToken;
        }
        // Certain browsers, e.g. Chrome, do not let you set the `User-Agent` header.
        const isBrowser = typeof window !== "undefined";
        if (!isBrowser) {
            let userAgent = `airplane/${this.opts.clientKind}/${this.opts.clientVersion}`;
            if (this.opts.teamID) {
                userAgent += " team/" + this.opts.teamID;
            }
            if (this.opts.runID) {
                userAgent += " run/" + this.opts.runID;
            }
            headers["User-Agent"] = userAgent;
        }
        const body = opts.body ? JSON.stringify(opts.body) : undefined;
        return fetchWithRetries({
            url: url.toString(),
            method,
            headers,
            body,
            abortSignal: opts.abortSignal,
            // Default to 10s.
            timeoutMs: (_f = opts.timeoutMs) !== null && _f !== void 0 ? _f : 10000,
            retryDelay: (_g = this.opts.retryDelay) !== null && _g !== void 0 ? _g : exports.defaultRetryDelay,
            mode: this.opts.mode,
            credentials: this.opts.credentials,
            agent: url.protocol === "http:" ? this.httpAgent : this.httpsAgent,
            retryNetworkErrors: (_h = opts.retryNetworkErrors) !== null && _h !== void 0 ? _h : true,
        });
    }
}
exports.Fetcher = Fetcher;
/** fetchWithRetries is a fetch wrapper that retries failed requests. */
const fetchWithRetries = async (req) => {
    var _a, _b, _c;
    let attempt = 1;
    const maxAttempt = 10;
    // The Retry-After header value, if any, from the previous request attempt.
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
    let retryAfterMs;
    // Retry the fetch request multiple times. We'll exit either by returning a successful response
    // or by throwing an error.
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const controller = new AbortController();
        const onAbort = () => {
            var _a;
            controller.abort();
            (_a = req.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", onAbort);
        };
        // If the abortSignal fires, cancel the AbortController in order to cancel the fetch request.
        (_a = req.abortSignal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", onAbort);
        // If the abortSignal has already fired, ensure the controller is also marked as aborted
        // so that the request immediately aborts.
        if ((_b = req.abortSignal) === null || _b === void 0 ? void 0 : _b.aborted) {
            onAbort();
        }
        // Apply exponential backoff between attempts.
        if (attempt > 1) {
            // Consider the server's Retry-After as a lower-bound.
            const durationMs = Math.max(retryAfterMs !== null && retryAfterMs !== void 0 ? retryAfterMs : 0, req.retryDelay(attempt));
            // If the abortSignal fires while sleeping, the sleeping will immediately stop.
            await (0, set_timeout_1.setTimeoutWithCancel)(durationMs, controller);
            retryAfterMs = undefined;
        }
        // Abort the request if it takes longer than `timeoutMs`.
        const timeout = setTimeout(() => controller.abort(), req.timeoutMs);
        try {
            const response = await (0, cross_fetch_1.default)(req.url, {
                method: req.method,
                headers: req.headers,
                body: req.body,
                signal: controller.signal,
                mode: req.mode,
                credentials: req.credentials,
                // We pass in a custom agent to re-use connections across multiple requests. This is only
                // supported in Node.js.
                // @ts-ignore
                agent: req.agent,
            });
            // If we got a 2xx status code, we can return successfully.
            if (response.status >= 200 && response.status < 300) {
                if ((0, exports.isJSONResponse)(response)) {
                    return (await response.json());
                }
                return (await response.text());
            }
            const { status } = response;
            const xAirplaneRetryable = response.headers.get("X-Airplane-Retryable");
            const canRetry = xAirplaneRetryable !== "false" &&
                (status === 429 || (status >= 500 && status !== 501) || xAirplaneRetryable === "true");
            if (!canRetry || attempt === maxAttempt) {
                throw await http_error_1.HTTPError.newFromResponse(req.method, response, attempt);
            }
            retryAfterMs = (0, exports.parseRetryAfter)(response.headers.get("retry-after"));
            // Otherwise, retry...
        }
        catch (err) {
            if (!(err instanceof Error)) {
                // fetch will not throw non-Error types, so this is unexpected.
                throw new Error(`Unexpectedly caught non-Error: ${typeof err}`);
            }
            // We throw an HTTPError if we encountered a response that can't be retried. Let it bubble up.
            if (err instanceof http_error_1.HTTPError) {
                throw err;
            }
            // Don't retry nock matching errors which indicate an invalid unit test.
            // See also: https://github.com/node-fetch/node-fetch/blob/main/docs/ERROR-HANDLING.md
            if (isFetchError(err) && err.type === "system" && err.errno === "ERR_NOCK_NO_MATCH") {
                throw err;
            }
            // If the client disabled retries on network errors, throw the error without retrying.
            //
            // Notably, the Fetch spec does not expose a way to detect if an error is a network error.
            // Upon a network error, a TypeError will be returned with a non-standardized error message, e.g.
            // - Chrome: "TypeError: Failed to fetch"
            // - Firefox: "TypeError: NetworkError when attempting to fetch resource"
            // - Safari: "TypeError: Load failed"
            //
            // We're left checking if the error is a TypeError and assuming it is a network error, however there
            // are a handful of other non-network errors that can cause TypeErrors, but they are all caused by
            // malformed requests: https://developer.mozilla.org/en-US/docs/Web/API/fetch#exceptions
            //
            // The fetch implementation used in Node (from node-fetch) differs from the spec in that it will
            // throw a FetchError with an ECONNREFUSED code.
            // See: https://github.com/node-fetch/node-fetch/blob/main/docs/ERROR-HANDLING.md
            if ((err instanceof TypeError || (isFetchError(err) && err.code === "ECONNREFUSED")) &&
                !req.retryNetworkErrors) {
                throw new http_error_1.HTTPError("Request failed due to network issue.", {
                    method: req.method,
                    url: req.url,
                    statusCode: 500,
                    errorCode: "NetworkError",
                    attempt,
                });
            }
            if (attempt === maxAttempt) {
                // Provide a nicer error if the failure was a timeout.
                if (err.name === "AbortError" && !((_c = req.abortSignal) === null || _c === void 0 ? void 0 : _c.aborted)) {
                    throw new http_error_1.HTTPError(`Request timed out after ${req.timeoutMs}ms.`, {
                        method: req.method,
                        url: req.url,
                        statusCode: 500,
                        attempt,
                    });
                }
                throw err;
            }
            // Otherwise, retry...
        }
        finally {
            attempt++;
            clearTimeout(timeout);
        }
    }
};
/**
 * Applies exponential backoff (with jitter) to compute how long to backoff between requests.
 *
 * Inspired by: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
 * @param attempt number of attempts that have been performed so far (should start at 1)
 * @returns a duration, in milliseconds, to backoff
 */
const defaultRetryDelay = (attempt) => {
    const baseMs = 200;
    const capMs = 30000;
    return Math.random() * Math.min(capMs, baseMs * Math.pow(2, attempt - 1));
};
exports.defaultRetryDelay = defaultRetryDelay;
const isJSONResponse = (response) => {
    var _a;
    const contentType = (_a = response.headers.get("content-type")) !== null && _a !== void 0 ? _a : "";
    return contentType.indexOf("application/json") > -1;
};
exports.isJSONResponse = isJSONResponse;
/**
 * Checks for and parses the Retry-After header, if any.
 *
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
 * @returns duration to wait, in milliseconds, else undefined if not set or invalid.
 */
const parseRetryAfter = (header) => {
    if (!header) {
        return undefined;
    }
    const durationSec = parseInt(header, 10);
    if (!isNaN(durationSec)) {
        // Convert to milliseconds.
        return durationSec * 1000;
    }
    const date = new Date(header);
    // Confirm the date is valid before returning.
    if (isNaN(date.getTime())) {
        return undefined;
    }
    // Convert the timestamp into a duration.
    return Math.max(0, date.getTime() - new Date().getTime());
};
exports.parseRetryAfter = parseRetryAfter;
const isFetchError = (err) => {
    return (err === null || err === void 0 ? void 0 : err.name) === "FetchError";
};
