"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPError = void 0;
const fetcher_1 = require("./fetcher");
const utils_1 = require("./utils");
class HTTPError extends Error {
    constructor(message, options) {
        super(message);
        this.name = "HTTPError";
        this.method = options.method;
        this.url = options.url;
        this.statusCode = options.statusCode;
        this.errorCode = options.errorCode;
        this.attempt = options.attempt;
        this.details = options.details;
        // Set the prototype explicitly so that instanceof checks work correctly.
        // This is a known issue ie. https://github.com/microsoft/TypeScript/issues/13965
        Object.setPrototypeOf(this, HTTPError.prototype);
    }
    static async newFromResponse(method, response, attempt) {
        // Attempt to parse the response as an error message:
        let message = `Request failed: ${response.status}: ${response.statusText}`;
        const options = {
            method,
            url: response.url,
            statusCode: response.status,
            attempt,
        };
        if ((0, fetcher_1.isJSONResponse)(response)) {
            try {
                const body = (await response.json());
                message = body.error || message;
                options.errorCode = body.code;
                options.details = body.details;
            }
            catch {
                // If we encounter a JSON parse error, ignore the response body.
            }
        }
        return new HTTPError(message, options);
    }
    static fromJSON(value) {
        if (value == null) {
            throw new Error(`Cannot deserialize HTTPError from ${value}`);
        }
        if (typeof value === "string") {
            value = JSON.parse(value);
        }
        if (typeof value !== "object") {
            throw new Error(`Expected object`);
        }
        const obj = value;
        const message = typeof obj.message === "string" ? obj.message : "";
        return new HTTPError(message, {
            method: typeof obj.method === "string" ? obj.method : "",
            url: typeof obj.url === "string" ? obj.url : "",
            statusCode: typeof obj.statusCode === "number" ? obj.statusCode : 0,
            errorCode: typeof obj.errorCode === "string" ? obj.errorCode : undefined,
            attempt: typeof obj.attempt === "number" ? obj.attempt : -1,
            details: (0, utils_1.isStringRecord)(obj.details) ? obj.details : undefined,
        });
    }
    toJSON() {
        // Error.message is not enumerable, so it is not serialized by default. This change ensures
        // that a serialized HTTPError includes `message`, in addition to all of its own properties.
        return Object.assign({ message: this.message }, this);
    }
    toString() {
        return `HTTPError: ${this.message} - ${this.method.toUpperCase()} ${this.url} (${this.statusCode})`;
    }
}
exports.HTTPError = HTTPError;
