"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runtime = void 0;
const lib_1 = require("@airplane/lib");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const uuid_1 = require("uuid");
const client_1 = require("../api/client");
const poller_1 = require("../api/poller");
const types_1 = require("../api/types");
const errors_1 = require("../errors");
const standard_1 = require("../sleep/standard");
const utils_1 = require("../sleep/utils");
exports.runtime = {
    execute: async (slug, paramValues = {}, resources, opts = {}) => {
        var _a, _b;
        const client = new client_1.Client(opts);
        let runID = "";
        let isCached = undefined;
        try {
            const resp = await client.executeTaskWithCacheInfo(slug, paramValues, resources);
            runID = resp.runID;
            isCached = resp.isCached;
        }
        catch (err) {
            if (!(err instanceof lib_1.HTTPError) || (err === null || err === void 0 ? void 0 : err.errorCode) !== errors_1.TASK_MUST_BE_REQUESTED_ERROR_CODE) {
                throw err;
            }
            const taskReviewers = await client.getTaskReviewers(slug);
            const formTrigger = (_b = (_a = taskReviewers.task) === null || _a === void 0 ? void 0 : _a.triggers) === null || _b === void 0 ? void 0 : _b.find((t) => t.kind === "form");
            if (!formTrigger) {
                throw new Error("Missing form trigger for task, unable to create request");
            }
            const triggerRequestID = await client.createTaskRequest(formTrigger.triggerID, slug, paramValues, "Automatically generated from parent run.", taskReviewers.reviewers);
            // Poll until the run is created or the trigger is rejected:
            const poller = new poller_1.Poller({ delayMs: 500 });
            runID = await poller.run(async () => {
                var _a, _b;
                const request = await client.getTriggerRequest(triggerRequestID);
                if (!(0, types_1.isRequestStatusTerminal)(request.status)) {
                    return null;
                }
                if (request.status === "rejected") {
                    throw new errors_1.RequestRejectionError();
                }
                runID = (_b = (_a = request === null || request === void 0 ? void 0 : request.triggerReceipt) === null || _a === void 0 ? void 0 : _a.taskRunID) !== null && _b !== void 0 ? _b : "";
                if (runID == "") {
                    throw new Error("Unable to find run ID for completed request");
                }
                return runID;
            });
        }
        // Poll until the run terminates:
        const poller = new poller_1.Poller({ delayMs: 500 });
        return poller.run(async () => {
            const run = await client.getRun(runID);
            if (!(0, types_1.isStatusTerminal)(run.status)) {
                return null;
            }
            const useZone = !!run.zoneID;
            const output = await client.getRunOutput(runID, { useZone });
            return {
                id: run.id,
                taskID: run.taskID,
                paramValues: run.paramValues,
                status: run.status,
                output,
                isCached,
            };
        });
    },
    executeBackground: async (slug, paramValues = {}, resources, opts = {}) => {
        const client = new client_1.Client(opts);
        return client.executeTask(slug, paramValues, resources);
    },
    executeBackgroundWithCacheInfo: async (slug, paramValues = {}, resources, opts = {}) => {
        const client = new client_1.Client(opts);
        return client.executeTaskWithCacheInfo(slug, paramValues, resources);
    },
    executeRunbook: async (slug, paramValues = {}, opts = {}) => {
        const client = new client_1.Client(opts);
        const sessionID = await client.executeRunbook(slug, paramValues);
        // Poll until the session terminates:
        const poller = new poller_1.Poller({ delayMs: 500 });
        return poller.run(async () => {
            const session = await client.getSession(sessionID);
            if (!(0, types_1.isSessionStatusTerminal)(session.status)) {
                return null;
            }
            return {
                id: session.id,
                runbookID: session.runbookID,
                paramValues: session.paramValues,
                status: session.status,
            };
        });
    },
    executeRunbookBackground: async (slug, paramValues = {}, opts = {}) => {
        const client = new client_1.Client(opts);
        return client.executeRunbook(slug, paramValues);
    },
    promptBackground: async (prompt) => {
        return await new client_1.Client().createPrompt(prompt);
    },
    waitForPrompt: async (promptID) => {
        const client = new client_1.Client();
        // Poll until the prompt is submitted:
        const poller = new poller_1.Poller({ delayMs: 500 });
        return poller.run(async () => {
            const prompt = await client.getPrompt(promptID);
            if (prompt.cancelledAt) {
                throw new errors_1.PromptCancelledError();
            }
            if (prompt.submittedAt == null) {
                return null;
            }
            return prompt.values;
        });
    },
    display: async (display, opts) => {
        const client = new client_1.Client(opts);
        await client.createDisplay(display);
    },
    sleep: async (ms, opts) => {
        const client = new client_1.Client(opts);
        const createSleep = async (dur) => {
            const now = new Date();
            await client.createSleep({
                durationMs: dur,
                until: (0, utils_1.calculateEndTimeISOString)(now.getTime(), dur),
            });
        };
        await Promise.all([(0, standard_1.standardSleep)(ms), createSleep(ms)]);
        return;
    },
    logChunks: (output) => {
        const CHUNK_SIZE = 8192;
        if (output.length <= CHUNK_SIZE) {
            console.log(output);
        }
        else {
            const chunkKey = (0, uuid_1.v4)();
            for (let i = 0; i < output.length; i += CHUNK_SIZE) {
                console.log(`airplane_chunk:${chunkKey} ${output.substring(i, i + CHUNK_SIZE)}`);
            }
            console.log(`airplane_chunk_end:${chunkKey}`);
        }
    },
    fetchBlob: async (url) => {
        const response = await (0, cross_fetch_1.default)(url, {});
        return response.blob();
    },
    createUpload: async (fileName, sizeBytes, opts = {}) => {
        const client = new client_1.Client(opts);
        return client.createUpload(fileName, sizeBytes);
    },
    uploadFileContents: async (url, payload, opts = {}) => {
        const client = new client_1.Client(opts);
        await client.uploadFileContents(url, payload);
    },
    getPrompt: async (promptID, opts = {}) => {
        const client = new client_1.Client(opts);
        return client.getPrompt(promptID);
    },
    getUser: async (userID, opts = {}) => {
        const client = new client_1.Client(opts);
        return await client.getUser(userID);
    },
    generateIDToken: async (audience, opts = {}) => {
        const client = new client_1.Client(opts);
        return await client.generateIDToken(audience);
    },
};
