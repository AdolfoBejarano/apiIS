import { InputParamValue } from "../params/params_input";
import { SerializedParams, SerializedParamValues } from "../params/params_serialized";
export type RunStatus = "NotStarted" | "Queued" | "Active" | "Succeeded" | "Failed" | "Cancelled";
export type SessionStatus = "Pending" | "Waiting" | "Active" | "Succeeded" | "Failed" | "Cancelling" | "Cancelled";
export type TriggerRequestStatus = "pending" | "approved" | "rejected";
export type TriggerKind = "" | "form" | "schedule";
export type Run<TParamValues extends SerializedParamValues = SerializedParamValues, TOutput = unknown> = {
    id: string;
    taskID?: string;
    paramValues: TParamValues;
    status: RunStatus;
    output: TOutput;
    isCached?: boolean;
};
export type TaskRun<TParamValues extends SerializedParamValues = SerializedParamValues, TOutput = unknown> = Run<TParamValues, TOutput> & {
    taskID: string;
};
export type BuiltInRun<TParamValues extends SerializedParamValues = SerializedParamValues, TOutput = unknown> = Omit<Run<TParamValues, TOutput>, "taskID">;
export type Session<P extends SerializedParamValues = SerializedParamValues> = {
    id: string;
    runbookID: string;
    paramValues: P;
    status: SessionStatus;
};
export declare const isStatusTerminal: (status: RunStatus) => boolean;
export declare const isRequestStatusTerminal: (status: TriggerRequestStatus) => boolean;
export declare const isSessionStatusTerminal: (status: SessionStatus) => boolean;
export type ConfigVar = {
    __airplaneType: "configvar";
    name: string;
    value: string;
};
export type PromptSchema = {
    parameters: SerializedParams;
};
export type CreatePromptRequest = {
    schema: PromptSchema;
    reviewers?: PromptReviewers;
    confirmText?: string;
    cancelText?: string;
    description?: string;
    notify?: boolean;
    zoneToken?: string;
};
export type CreateSleepRequest = {
    durationMs: number;
    until: string;
};
export type PromptReviewers = {
    /** List of groups allowed to approve the prompt. Groups are referenced via their slugs. */
    groups?: string[];
    /** List of users allowed to approve the prompt. Users are referenced via their emails. */
    users?: string[];
    /** Whether or not the run creator is allowed to approve their own prompt. Defaults to true. */
    allowSelfApprovals?: boolean;
};
export type ParamValues = {
    [slug: string]: InputParamValue;
};
export type Prompt = {
    id: string;
    schema: SerializedParams;
    values: SerializedParamValues;
    submittedAt: string | null;
    submittedBy: string | null;
    cancelledAt: string | null;
    cancelledBy: string | null;
    zoneToken?: string;
};
export type AgentPromptData = {
    token: string;
    schema: SerializedParams;
    values: SerializedParamValues;
};
export type Sleep = {
    id: string;
    runID: string;
    createdAt: string;
    until: string;
    durationMs: number;
    skippedAt?: string;
    skippedBy?: string;
};
type DisplayBase = {
    id: string;
    createdAt: string;
};
export type Display = DisplayBase & DisplayConfig;
export type DisplayConfig = DisplayTextConfig | DisplayTableConfig | DisplayJSONConfig | DisplayFileConfig;
export type DisplayKind = Display["kind"];
export type DisplayTextConfig = {
    kind: "markdown";
    content: string;
};
export type DisplayTableColumnConfig<TColumnSlug extends string = string> = {
    name?: string;
    slug: TColumnSlug;
};
export type DisplayTableConfig<TColumnSlug extends string = string> = {
    kind: "table";
    columns: readonly DisplayTableColumnConfig<TColumnSlug>[];
    rows: readonly Record<TColumnSlug, unknown>[];
};
export type DisplayJSONConfig = {
    kind: "json";
    value: unknown;
};
export type DisplayFileConfig = {
    kind: "file";
    uploadID: string;
};
export type TriggerReceipt = {
    taskRunID?: string;
    runbookSessionID?: string;
};
export type TriggerRequest = {
    iD: string;
    teamID: string;
    createdAt: string;
    createdBy: string;
    reason: string;
    triggerReceipt?: TriggerReceipt;
    status: TriggerRequestStatus;
    reviewers: Reviewer[];
    executedAt?: string;
    executedBy?: string;
    rejectedReason?: string;
    rejectedAt?: string;
    rejectedBy?: string;
};
export type TaskReviewers = {
    task?: Task;
    reviewers?: Reviewer[];
};
export type Task = {
    id: string;
    name: string;
    slug: string;
    description: string;
    image?: string;
    command: string[];
    arguments: string[];
    parameters: SerializedParams;
    resourceRequests: Record<string, unknown>;
    resources: Record<string, unknown>;
    kindOptions: Record<string, unknown>;
    repo: string;
    requireExplicitPermissions: boolean;
    timeout: number;
    isArchived: boolean;
    parentFolderID?: string;
    createdAt: string;
    updatedAt: string;
    revisionID: string;
    deploymentID?: string;
    triggers: Trigger[];
};
export type Trigger = {
    triggerID: string;
    teamID: string;
    name: string;
    description: string;
    slug?: string;
    taskID?: string;
    runbookID?: string;
    kind: TriggerKind;
    disabledAt?: string;
    disabledReason?: string;
    envID: string;
    createdAt: string;
    createdBy: string;
    updatedAt: string;
    updatedBy: string;
    archivedAt?: string;
    archivedBy?: string;
};
export type Reviewer = {
    userID: string;
    groupID: string;
};
export type Upload = {
    id: string;
    fileName: string;
    url: string;
    sizeBytes: number;
    createdAt: string;
    teamID: string;
    creatorUserID?: string;
    runID?: string;
    triggerRequestID?: string;
    sessionID?: string;
    zoneID?: string;
    zoneToken?: string;
};
export type CreateUploadResponse = {
    upload: Upload;
    readOnlyURL: string;
    writeOnlyURL: string;
};
export type User = {
    userID: string;
    email: string;
    name: string;
};
export type Zone = {
    id: string;
    dataPlaneURL: string;
    accessToken: string;
};
export type PickZoneResponse = {
    zone?: Zone;
    passthroughParams: string[];
    constraintParams: string[];
    parameters: {
        parameters: SerializedParams;
    };
};
export type ExecuteBackgroundResponse = {
    runID: string;
    isCached?: boolean;
};
export {};
