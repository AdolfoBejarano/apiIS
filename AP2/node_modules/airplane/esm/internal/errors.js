export const TASK_MUST_BE_REQUESTED_ERROR_CODE = "task_must_be_requested";
export class RunTerminationError extends Error {
    constructor(run, slug) {
        let message = getRunErrorMessage(run);
        if (!message) {
            message = slug
                ? `Run for task "${slug}" ${run.status.toLowerCase()}`
                : `Run ${run.status.toLowerCase()}`;
        }
        super(message);
        this.run = run;
        this.slug = slug;
        this.name = "RunTerminationError";
        Object.setPrototypeOf(this, RunTerminationError.prototype);
    }
}
export class RequestRejectionError extends Error {
    constructor() {
        super(`Request rejected`);
        this.name = "RequestRejectionError";
        Object.setPrototypeOf(this, RequestRejectionError.prototype);
    }
}
export class PromptCancelledError extends Error {
    constructor() {
        super(`Prompt cancelled`);
        this.name = "PromptCancelledError";
        Object.setPrototypeOf(this, PromptCancelledError.prototype);
    }
}
export class SessionTerminationError extends Error {
    constructor(session) {
        super(`Session ${session.status.toLowerCase()}`);
        this.session = session;
        this.name = "SessionTerminationError";
        Object.setPrototypeOf(this, SessionTerminationError.prototype);
    }
}
// getRunErrorMessage extracts an error message from a run's output, if any.
const getRunErrorMessage = (run) => {
    if (!run.output || typeof run.output !== "object") {
        return undefined;
    }
    if (!("error" in run.output)) {
        return undefined;
    }
    const output = run.output;
    if (typeof output["error"] !== "string") {
        return undefined;
    }
    return output["error"];
};
