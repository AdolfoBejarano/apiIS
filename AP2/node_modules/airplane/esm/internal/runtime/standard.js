import { HTTPError } from "@airplane/lib";
import fetch from "cross-fetch";
import { v4 as uuidv4 } from "uuid";
import { Client } from "../api/client";
import { Poller } from "../api/poller";
import { isRequestStatusTerminal, isSessionStatusTerminal, isStatusTerminal, } from "../api/types";
import { PromptCancelledError, RequestRejectionError, TASK_MUST_BE_REQUESTED_ERROR_CODE, } from "../errors";
import { standardSleep } from "../sleep/standard";
import { calculateEndTimeISOString } from "../sleep/utils";
export const runtime = {
    execute: async (slug, paramValues = {}, resources, opts = {}) => {
        var _a, _b;
        const client = new Client(opts);
        let runID = "";
        let isCached = undefined;
        try {
            const resp = await client.executeTaskWithCacheInfo(slug, paramValues, resources);
            runID = resp.runID;
            isCached = resp.isCached;
        }
        catch (err) {
            if (!(err instanceof HTTPError) || (err === null || err === void 0 ? void 0 : err.errorCode) !== TASK_MUST_BE_REQUESTED_ERROR_CODE) {
                throw err;
            }
            const taskReviewers = await client.getTaskReviewers(slug);
            const formTrigger = (_b = (_a = taskReviewers.task) === null || _a === void 0 ? void 0 : _a.triggers) === null || _b === void 0 ? void 0 : _b.find((t) => t.kind === "form");
            if (!formTrigger) {
                throw new Error("Missing form trigger for task, unable to create request");
            }
            const triggerRequestID = await client.createTaskRequest(formTrigger.triggerID, slug, paramValues, "Automatically generated from parent run.", taskReviewers.reviewers);
            // Poll until the run is created or the trigger is rejected:
            const poller = new Poller({ delayMs: 500 });
            runID = await poller.run(async () => {
                var _a, _b;
                const request = await client.getTriggerRequest(triggerRequestID);
                if (!isRequestStatusTerminal(request.status)) {
                    return null;
                }
                if (request.status === "rejected") {
                    throw new RequestRejectionError();
                }
                runID = (_b = (_a = request === null || request === void 0 ? void 0 : request.triggerReceipt) === null || _a === void 0 ? void 0 : _a.taskRunID) !== null && _b !== void 0 ? _b : "";
                if (runID == "") {
                    throw new Error("Unable to find run ID for completed request");
                }
                return runID;
            });
        }
        // Poll until the run terminates:
        const poller = new Poller({ delayMs: 500 });
        return poller.run(async () => {
            const run = await client.getRun(runID);
            if (!isStatusTerminal(run.status)) {
                return null;
            }
            const useZone = !!run.zoneID;
            const output = await client.getRunOutput(runID, { useZone });
            return {
                id: run.id,
                taskID: run.taskID,
                paramValues: run.paramValues,
                status: run.status,
                output,
                isCached,
            };
        });
    },
    executeBackground: async (slug, paramValues = {}, resources, opts = {}) => {
        const client = new Client(opts);
        return client.executeTask(slug, paramValues, resources);
    },
    executeBackgroundWithCacheInfo: async (slug, paramValues = {}, resources, opts = {}) => {
        const client = new Client(opts);
        return client.executeTaskWithCacheInfo(slug, paramValues, resources);
    },
    executeRunbook: async (slug, paramValues = {}, opts = {}) => {
        const client = new Client(opts);
        const sessionID = await client.executeRunbook(slug, paramValues);
        // Poll until the session terminates:
        const poller = new Poller({ delayMs: 500 });
        return poller.run(async () => {
            const session = await client.getSession(sessionID);
            if (!isSessionStatusTerminal(session.status)) {
                return null;
            }
            return {
                id: session.id,
                runbookID: session.runbookID,
                paramValues: session.paramValues,
                status: session.status,
            };
        });
    },
    executeRunbookBackground: async (slug, paramValues = {}, opts = {}) => {
        const client = new Client(opts);
        return client.executeRunbook(slug, paramValues);
    },
    promptBackground: async (prompt) => {
        return await new Client().createPrompt(prompt);
    },
    waitForPrompt: async (promptID) => {
        const client = new Client();
        // Poll until the prompt is submitted:
        const poller = new Poller({ delayMs: 500 });
        return poller.run(async () => {
            const prompt = await client.getPrompt(promptID);
            if (prompt.cancelledAt) {
                throw new PromptCancelledError();
            }
            if (prompt.submittedAt == null) {
                return null;
            }
            return prompt.values;
        });
    },
    display: async (display, opts) => {
        const client = new Client(opts);
        await client.createDisplay(display);
    },
    sleep: async (ms, opts) => {
        const client = new Client(opts);
        const createSleep = async (dur) => {
            const now = new Date();
            await client.createSleep({
                durationMs: dur,
                until: calculateEndTimeISOString(now.getTime(), dur),
            });
        };
        await Promise.all([standardSleep(ms), createSleep(ms)]);
        return;
    },
    logChunks: (output) => {
        const CHUNK_SIZE = 8192;
        if (output.length <= CHUNK_SIZE) {
            console.log(output);
        }
        else {
            const chunkKey = uuidv4();
            for (let i = 0; i < output.length; i += CHUNK_SIZE) {
                console.log(`airplane_chunk:${chunkKey} ${output.substring(i, i + CHUNK_SIZE)}`);
            }
            console.log(`airplane_chunk_end:${chunkKey}`);
        }
    },
    fetchBlob: async (url) => {
        const response = await fetch(url, {});
        return response.blob();
    },
    createUpload: async (fileName, sizeBytes, opts = {}) => {
        const client = new Client(opts);
        return client.createUpload(fileName, sizeBytes);
    },
    uploadFileContents: async (url, payload, opts = {}) => {
        const client = new Client(opts);
        await client.uploadFileContents(url, payload);
    },
    getPrompt: async (promptID, opts = {}) => {
        const client = new Client(opts);
        return client.getPrompt(promptID);
    },
    getUser: async (userID, opts = {}) => {
        const client = new Client(opts);
        return await client.getUser(userID);
    },
    generateIDToken: async (audience, opts = {}) => {
        const client = new Client(opts);
        return await client.generateIDToken(audience);
    },
};
