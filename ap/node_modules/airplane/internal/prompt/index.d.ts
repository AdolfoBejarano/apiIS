import { BasePromptOptions, PromptOptions } from "./options";
import { User } from "../api/types";
import { InputToOutputParamValues, PromptInputParams } from "../params/params_input";
import { Resolve } from "../type_helpers";
export type { PromptOptions };
/**
 * Prompts a user for confirmation without requiring parameters.
 * @param opts Configuration options.
 */
export declare const confirm: (opts?: BasePromptOptions) => Promise<void>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const text: (name: string, opts?: PromptOptions<string>) => Promise<string>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const longText: (name: string, opts?: PromptOptions<string>) => Promise<string>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const sql: (name: string, opts?: PromptOptions<string>) => Promise<string>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const number: (name: string, opts?: PromptOptions<number>) => Promise<number>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const integer: (name: string, opts?: PromptOptions<number>) => Promise<number>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const boolean: (name: string, opts?: PromptOptions<boolean>) => Promise<boolean>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const date: (name: string, opts?: PromptOptions<string | Date>) => Promise<Date>;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export declare const datetime: (name: string, opts?: PromptOptions<string | Date>) => Promise<Date>;
/**
 * Prompts a user to select one item from a list of options.
 * @param name The heading rendered above the parameter
 * @param options The list of possible options to select from. If empty and a selection is required, an error is thrown.
 * @param opts Additional configuration options
 * @returns The selected option
 * @example
 *   select("Slug", slugs, { description: "The slug to assign to the new team.", default: slugs[0] })
 * @example
 *   // Provide labels when working with a list of objects
 *   select("User", users, { optionToLabel: user => user.name })
 */
export declare const select: <TOption = unknown>(name: string, options: readonly TOption[], opts?: BasePromptOptions & {
    slug?: string | undefined;
    required?: boolean | undefined;
    default?: TOption | undefined;
    multi?: boolean | undefined;
    regex?: RegExp | undefined;
    options?: (TOption | import("../params/params").SelectOption<TOption>)[] | undefined;
} & {
    /**
     * An optional function to convert an option into a human-readable label.
     *
     * If not supplied, the option is best-effort converted into a string.
     *
     * Recommended if options are objects.
     */
    optionToLabel?: ((option: TOption) => string) | undefined;
}) => Promise<TOption>;
/**
 * Prompts an operator for input.
 *
 * Each prompt contains a parameter form, similar to what you see when executing a task or runbook.
 * When a prompt is created, the run pauses⁠ and waits for a response⁠ before continuing.
 * By default, anyone who can access the associated run can also respond to the prompt,
 * but this can be restricted by specifying reviewers in the prompt's options. As a convenience,
 * you can use `prompt.confirm` to create prompts with no parameters.
 * @param params Defines the parameter form as a mapping of slug to parameter.
 * The values will be returned as an object that maps the parameter slug to the corresponding value.
 * To learn more about parameters, see the [Parameter documentation](https://docs.airplane.dev/platform/parameters).
 * @param opts Additional configuration options
 * @example
 *   // Prompt user to input a refund amount and reason.
 *   const { amount, reason } = await prompt(
 *     {
 *       amount: "integer",
 *       reason: "shorttext",
 *     },
 *     { confirmText: "Accept refund" }
 *   );
 * @example
 *   // Prompt with a list of options to choose from. As a convenience, you can use
 *   // `prompt.select` to create a prompt with a list of objects.
 *   const { username } = await prompt({
 *     username: {
 *       type: "shorttext",
 *       options: ["colin", "eric"],
 *     },
 *   });
 */
export declare const prompt: {
    <TParams extends PromptInputParams>(params: TParams, opts?: BasePromptOptions): Promise<Resolve<InputToOutputParamValues<TParams>>>;
    text: (name: string, opts?: PromptOptions<string>) => Promise<string>;
    longText: (name: string, opts?: PromptOptions<string>) => Promise<string>;
    sql: (name: string, opts?: PromptOptions<string>) => Promise<string>;
    number: (name: string, opts?: PromptOptions<number>) => Promise<number>;
    integer: (name: string, opts?: PromptOptions<number>) => Promise<number>;
    boolean: (name: string, opts?: PromptOptions<boolean>) => Promise<boolean>;
    date: (name: string, opts?: PromptOptions<string | Date>) => Promise<Date>;
    datetime: (name: string, opts?: PromptOptions<string | Date>) => Promise<Date>;
    confirm: (opts?: BasePromptOptions) => Promise<void>;
    select: <TOption = unknown>(name: string, options: readonly TOption[], opts?: BasePromptOptions & {
        slug?: string | undefined;
        required?: boolean | undefined;
        default?: TOption | undefined;
        multi?: boolean | undefined;
        regex?: RegExp | undefined;
        options?: (TOption | import("../params/params").SelectOption<TOption>)[] | undefined;
    } & {
        /**
         * An optional function to convert an option into a human-readable label.
         *
         * If not supplied, the option is best-effort converted into a string.
         *
         * Recommended if options are objects.
         */
        optionToLabel?: ((option: TOption) => string) | undefined;
    }) => Promise<TOption>;
    background: <TParams_1 extends PromptInputParams>(params: TParams_1, opts?: BasePromptOptions) => Promise<Prompt<TParams_1>>;
};
/**
 * Prompts an operator for input and does not wait for the prompt to be submitted. The prompt response
 * can be retrieved by calling `.wait()` on the returned object. As a convenience,
 * you can use `prompt()` to create a prompt and wait for a response.
 *
 * Each prompt contains a parameter form, similar to what you see when executing a task or runbook.
 * When a prompt is created, the run pauses⁠ and waits for a response⁠ before continuing.
 * By default, anyone who can access the associated run can also respond to the prompt,
 * but this can be restriced by specifying reviewers in the prompt's options.
 * @param params Defines the parameter form as a mapping of slug to parameter.
 * The values will be returned as an object that maps the parameter slug to the corresponding value.
 * To learn more about parameters, see the [Parameter documentation](https://docs.airplane.dev/platform/parameters).
 * @param opts Additional configuration options
 * @example
 *   // Prompt user to input a refund amount and reason.
 *   const prompt = await prompt.background(
 *     {
 *       amount: "integer",
 *       reason: "shorttext",
 *     },
 *     { confirmText: "Accept refund" }
 *   );
 *   const { amount, reason } = await prompt.wait();
 * @example
 *   // Prompt with a list of options to choose from.
 *   const prompt = await prompt.background({
 *     username: {
 *       type: "shorttext",
 *       options: ["colin", "eric"],
 *     },
 *   });
 *   const { username } = await prompt.wait();
 */
export declare const background: <TParams extends PromptInputParams>(params: TParams, opts?: BasePromptOptions) => Promise<Prompt<TParams>>;
export declare class Prompt<TParams extends PromptInputParams> {
    readonly params: TParams;
    readonly promptID: string;
    constructor(params: TParams, promptID: string);
    /**
     * Waits on an operator for prompt input.
     * @example
     *   // Prompt user to input a refund amount and reason.
     *   const prompt = await airplane.prompt.background(
     *     {
     *       amount: "integer",
     *       reason: "shorttext",
     *     },
     *     { confirmText: "Accept refund" }
     *   );
     *   const { amount, reason } = await prompt.wait();
     */
    wait(): Promise<Resolve<InputToOutputParamValues<TParams>>>;
    /**
     * Returns the user who submitted the prompt, if there is one.
     */
    submitter(): Promise<User | undefined>;
}
