"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Prompt = exports.background = exports.prompt = exports.select = exports.datetime = exports.date = exports.boolean = exports.integer = exports.number = exports.sql = exports.longText = exports.text = exports.confirm = void 0;
const fast_equals_1 = require("fast-equals");
const ts_dedent_1 = require("ts-dedent");
const options_1 = require("./options");
const params_output_1 = require("../params/params_output");
const params_serialized_1 = require("../params/params_serialized");
const runtime_1 = require("../runtime");
/**
 * Prompts a user for confirmation without requiring parameters.
 * @param opts Configuration options.
 */
const confirm = async (opts = {}) => {
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        description: opts.description ? (0, ts_dedent_1.dedent)(opts.description) : undefined,
        notify: opts.notify,
    });
    await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    return;
};
exports.confirm = confirm;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const text = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "shorttext", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    return values[param.slug];
};
exports.text = text;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const longText = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "longtext", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    return values[param.slug];
};
exports.longText = longText;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const sql = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "sql", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    return values[param.slug];
};
exports.sql = sql;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const number = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "float", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    return values[param.slug];
};
exports.number = number;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const integer = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "integer", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    return values[param.slug];
};
exports.integer = integer;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const boolean = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "boolean", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    return values[param.slug];
};
exports.boolean = boolean;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const date = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "date", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    // Convert back to Dates before passing back.
    return new Date(values[param.slug]);
};
exports.date = date;
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
const datetime = async (name, opts = {}) => {
    const param = (0, options_1.optionsToSchema)(name, "datetime", opts);
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    // Convert back to Dates before passing back.
    return new Date(values[param.slug]);
};
exports.datetime = datetime;
/**
 * Prompts a user to select one item from a list of options.
 * @param name The heading rendered above the parameter
 * @param options The list of possible options to select from. If empty and a selection is required, an error is thrown.
 * @param opts Additional configuration options
 * @returns The selected option
 * @example
 *   select("Slug", slugs, { description: "The slug to assign to the new team.", default: slugs[0] })
 * @example
 *   // Provide labels when working with a list of objects
 *   select("User", users, { optionToLabel: user => user.name })
 */
const select = async (name, options, opts = {}) => {
    var _a;
    const optionToLabel = (_a = opts.optionToLabel) !== null && _a !== void 0 ? _a : ((option) => {
        switch (typeof option) {
            case "bigint":
            case "boolean":
            case "number":
                return String(option);
            case "string":
                return option;
        }
        if (option instanceof Date) {
            return option.toISOString();
        }
        return JSON.stringify(option);
    });
    const param = (0, options_1.optionsToSchema)(name, "integer", {
        ...opts,
        options: options.map((option, i) => ({ label: optionToLabel(option), value: i })),
        default: opts.default
            ? options.findIndex((option) => (0, fast_equals_1.deepEqual)(option, opts.default))
            : undefined,
    });
    if (options.length === 0 && !param.constraints.optional) {
        throw new Error(`The required prompt parameter, "${name}", has no options to select from.`);
    }
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await (0, runtime_1.getRuntime)().waitForPrompt(promptID);
    const i = values[param.slug];
    // TODO: update type system to handle optionals
    if (i == null) {
        throw new Error(`An option was not selected`);
    }
    return options[i];
};
exports.select = select;
/**
 * Prompts an operator for input.
 *
 * Each prompt contains a parameter form, similar to what you see when executing a task or runbook.
 * When a prompt is created, the run pauses⁠ and waits for a response⁠ before continuing.
 * By default, anyone who can access the associated run can also respond to the prompt,
 * but this can be restricted by specifying reviewers in the prompt's options. As a convenience,
 * you can use `prompt.confirm` to create prompts with no parameters.
 * @param params Defines the parameter form as a mapping of slug to parameter.
 * The values will be returned as an object that maps the parameter slug to the corresponding value.
 * To learn more about parameters, see the [Parameter documentation](https://docs.airplane.dev/platform/parameters).
 * @param opts Additional configuration options
 * @example
 *   // Prompt user to input a refund amount and reason.
 *   const { amount, reason } = await prompt(
 *     {
 *       amount: "integer",
 *       reason: "shorttext",
 *     },
 *     { confirmText: "Accept refund" }
 *   );
 * @example
 *   // Prompt with a list of options to choose from. As a convenience, you can use
 *   // `prompt.select` to create a prompt with a list of objects.
 *   const { username } = await prompt({
 *     username: {
 *       type: "shorttext",
 *       options: ["colin", "eric"],
 *     },
 *   });
 */
const prompt = async (params, opts = {}) => {
    return await (await (0, exports.background)(params, opts)).wait();
};
exports.prompt = prompt;
/**
 * Prompts an operator for input and does not wait for the prompt to be submitted. The prompt response
 * can be retrieved by calling `.wait()` on the returned object. As a convenience,
 * you can use `prompt()` to create a prompt and wait for a response.
 *
 * Each prompt contains a parameter form, similar to what you see when executing a task or runbook.
 * When a prompt is created, the run pauses⁠ and waits for a response⁠ before continuing.
 * By default, anyone who can access the associated run can also respond to the prompt,
 * but this can be restriced by specifying reviewers in the prompt's options.
 * @param params Defines the parameter form as a mapping of slug to parameter.
 * The values will be returned as an object that maps the parameter slug to the corresponding value.
 * To learn more about parameters, see the [Parameter documentation](https://docs.airplane.dev/platform/parameters).
 * @param opts Additional configuration options
 * @example
 *   // Prompt user to input a refund amount and reason.
 *   const prompt = await prompt.background(
 *     {
 *       amount: "integer",
 *       reason: "shorttext",
 *     },
 *     { confirmText: "Accept refund" }
 *   );
 *   const { amount, reason } = await prompt.wait();
 * @example
 *   // Prompt with a list of options to choose from.
 *   const prompt = await prompt.background({
 *     username: {
 *       type: "shorttext",
 *       options: ["colin", "eric"],
 *     },
 *   });
 *   const { username } = await prompt.wait();
 */
const background = async (params, opts = {}) => {
    const promptID = await (0, runtime_1.getRuntime)().promptBackground({
        schema: {
            parameters: (0, params_serialized_1.serializeParams)(params),
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        description: opts.description ? (0, ts_dedent_1.dedent)(opts.description) : undefined,
        notify: opts.notify,
    });
    return new Prompt(params, promptID);
};
exports.background = background;
class Prompt {
    constructor(params, promptID) {
        this.params = params;
        this.promptID = promptID;
        this.params = params;
        this.promptID = promptID;
    }
    /**
     * Waits on an operator for prompt input.
     * @example
     *   // Prompt user to input a refund amount and reason.
     *   const prompt = await airplane.prompt.background(
     *     {
     *       amount: "integer",
     *       reason: "shorttext",
     *     },
     *     { confirmText: "Accept refund" }
     *   );
     *   const { amount, reason } = await prompt.wait();
     */
    async wait() {
        const values = await (0, runtime_1.getRuntime)().waitForPrompt(this.promptID);
        return (0, params_output_1.deserializeParamValues)(this.params, values);
    }
    /**
     * Returns the user who submitted the prompt, if there is one.
     */
    async submitter() {
        const prompt = await (0, runtime_1.getRuntime)().getPrompt(this.promptID);
        if (prompt.submittedBy == null) {
            return undefined;
        }
        return await (0, runtime_1.getRuntime)().getUser(prompt.submittedBy);
    }
}
exports.Prompt = Prompt;
// Attach convenience methods for backwards compatibility.
exports.prompt.text = exports.text;
exports.prompt.longText = exports.longText;
exports.prompt.sql = exports.sql;
exports.prompt.number = exports.number;
exports.prompt.integer = exports.integer;
exports.prompt.boolean = exports.boolean;
exports.prompt.date = exports.date;
exports.prompt.datetime = exports.datetime;
exports.prompt.confirm = exports.confirm;
exports.prompt.select = exports.select;
exports.prompt.background = exports.background;
