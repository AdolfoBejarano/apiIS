"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runtime = void 0;
const lib_1 = require("@airplane/lib");
const standard_1 = require("./standard");
const client_1 = require("../api/client");
const poller_1 = require("../api/poller");
const utils_1 = require("../sleep/utils");
exports.runtime = {
    execute: async (slug, paramValues = {}, resources, opts = {}) => {
        return standard_1.runtime.execute(slug, paramValues, resources, opts);
    },
    executeBackground: async (slug, paramValues = {}, resources, opts = {}) => {
        return standard_1.runtime.executeBackground(slug, paramValues, resources, opts);
    },
    executeRunbook: async (slug, paramValues = {}, opts = {}) => {
        return standard_1.runtime.executeRunbook(slug, paramValues, opts);
    },
    executeRunbookBackground: async (slug, paramValues, opts) => {
        return standard_1.runtime.executeRunbookBackground(slug, paramValues, opts);
    },
    promptBackground: async (prompt) => {
        return standard_1.runtime.promptBackground(prompt);
    },
    waitForPrompt: async (promptID) => {
        return standard_1.runtime.waitForPrompt(promptID);
    },
    display: async (display) => {
        await standard_1.runtime.display(display);
    },
    sleep: async (duration) => {
        const client = new client_1.Client();
        const now = new Date();
        const sleepID = await client.createSleep({
            durationMs: duration,
            until: (0, utils_1.calculateEndTimeISOString)(now.getTime(), duration),
        });
        let isSleepFinished = false;
        // Create an AbortController to cancel the sleep if it is skipped.
        const controller = new AbortController();
        const localSleep = async () => {
            await (0, lib_1.setTimeoutWithCancel)(duration, controller);
            isSleepFinished = true;
        };
        const checkSkip = async (id) => {
            const poller = new poller_1.Poller({ delayMs: 500 });
            await poller.run(async () => {
                if (isSleepFinished) {
                    return true;
                }
                const sleep = await client.getSleep(id);
                if (sleep.skippedAt !== null) {
                    // Abort the timeout if the sleep was skipped.
                    controller.abort();
                    return true;
                }
                return null;
            });
        };
        // Wait for either the sleep to finish or for the sleep to be skipped.
        await Promise.all([localSleep(), checkSkip(sleepID)]);
    },
    getPrompt: async (promptID) => {
        return await standard_1.runtime.getPrompt(promptID);
    },
    getUser: async (userID) => {
        return await standard_1.runtime.getUser(userID);
    },
    logChunks: (output) => {
        standard_1.runtime.logChunks(output);
    },
    fetchBlob: async (url) => {
        return standard_1.runtime.fetchBlob(url);
    },
    createUpload: async (fileName, sizeBytes) => {
        return standard_1.runtime.createUpload(fileName, sizeBytes);
    },
    uploadFileContents: async (url, payload) => {
        return standard_1.runtime.uploadFileContents(url, payload);
    },
    generateIDToken: async (audience) => {
        return standard_1.runtime.generateIDToken(audience);
    },
};
