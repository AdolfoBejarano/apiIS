/**
 * Resolve forces TypeScript to resolve generics into an underlying object.
 * It helps produce more intelligible types: https://effectivetypescript.com/2022/02/25/gentips-4-display/
 */
export type Resolve<T> = T extends Function ? T : {
    [K in keyof T]: T[K];
};
/**
 * Optional returns T with all keys K marked optional. Similar to Partial, but can
 * be applied to a subset of keys.
 */
export type Optional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
/**
 * IfEmptyUndefined checks if TValue accepts an empty object; if so, it allows it to also accept undefined.
 */
export type IfEmptyUndefined<TValue> = Record<string, never> extends TValue ? TValue | undefined : TValue;
/**
 * Like keyof, but returns the values of a type.
 */
export type ValueOf<T> = T[keyof T];
