import { getRuntime } from "../runtime";
/**
 * Appends a display to the run that renders a table.
 *
 * Each row should be an object mapping header slugs to values. Columns that are not
 * specified will default to `null`. The selection, ordering, and naming of columns
 * can be customized via `opts.columns`.
 * @example
 *   await table([
 *     { "name": "Lilo", age: 6 },
 *     { "name": "Stitch" },
 *   ])
 * @param rows The list of rows to render in the table
 * @param opts Additional configuration options
 */
export const table = async (rows, opts = {}) => {
    let cfg;
    if (opts.columns) {
        // Convert string[] -> DisplayTableColumnConfig[], if necessary
        const columns = opts.columns.length > 0 && typeof opts.columns[0] === "string"
            ? opts.columns.map((c) => ({ slug: c }))
            : opts.columns;
        cfg = {
            kind: "table",
            columns,
            rows: filterRowsByColumns(rows, columns),
        };
    }
    else {
        cfg = {
            kind: "table",
            columns: columnsFromRows(rows),
            rows,
        };
    }
    await getRuntime().display(cfg);
};
export const columnsFromRows = (rows) => {
    const columns = [];
    const knownColumns = new Set();
    for (const row of rows) {
        for (const key of Object.keys(row)) {
            if (!knownColumns.has(key)) {
                columns.push({ slug: key });
                knownColumns.add(key);
            }
        }
    }
    return columns;
};
export const filterRowsByColumns = (rows, columns) => {
    const knownColumns = new Set(columns.map((c) => c.slug));
    if (knownColumns.size !== columns.length) {
        throw new Error(`Expected column slugs to be unique`);
    }
    if (columns.some((c) => !c.slug)) {
        throw new Error(`Column slugs cannot be empty`);
    }
    const isKnownKey = (key) => {
        return knownColumns.has(key);
    };
    const filteredRows = [];
    for (const row of rows) {
        const keys = Object.keys(row);
        const knownKeys = keys.filter(isKnownKey);
        if (keys.length === knownKeys.length) {
            filteredRows.push(row);
        }
        else {
            const filteredRow = {};
            for (const key of knownKeys) {
                filteredRow[key] = row[key];
            }
            filteredRows.push(filteredRow);
        }
    }
    return filteredRows;
};
