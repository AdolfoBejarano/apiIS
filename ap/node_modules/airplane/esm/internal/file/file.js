var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AirplaneFile_instances, _a, _AirplaneFile_blob, _AirplaneFile_download, _AirplaneFile_extractName;
import mime from "mime";
import { isAirplaneFileObject } from "./file_object";
import { getRuntime } from "../runtime";
/**
 * AirplaneFile is a helper for reading and writing files. It can be used to fetch the contents
 * of a file parameter and can be passed as a file parameter when executing a task.
 *
 * The AirplaneFile API mirrors [the Blob API](https://developer.mozilla.org/en-US/docs/Web/API/Blob). Unlike
 * Blob, AirplaneFile lazily loads the contents of the file. This allows AirplaneFile to be used as a reference
 * to a file without having to download its contents (e.g. passing a parameter from one task to another).
 * @example
 *   function(params) {
 *     const file = new AirplaneFile(params.my_file);
 *     const contents = await file.text()
 *     console.log(`got: ${contents}`)
 *   }
 */
export class AirplaneFile {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...args) {
        var _b, _c, _d, _e, _f, _g;
        _AirplaneFile_instances.add(this);
        /**
         * The `__airplaneType` field identifies objects as a specific type of Airplane object. Airplane files are
         * identified by the type, "upload".
         */
        this.__airplaneType = "upload";
        /**
         * The in-memory representation of the file's contents.
         *
         * The contents of the file are lazily-loaded upon a request for the file's contents. The contents are
         * considered immutable and are cached indefinitely.
         */
        _AirplaneFile_blob.set(this, void 0);
        if (isAirplaneFileObject(args[0])) {
            const o = args[0];
            this.id = o.id;
            this.url = o.url;
            this.name = __classPrivateFieldGet(_a, _a, "m", _AirplaneFile_extractName).call(_a, o.url);
            this.size = 0;
            this.type = "";
        }
        else if (isBlob(args[0])) {
            const blob = args[0];
            const metadata = args[1];
            __classPrivateFieldSet(this, _AirplaneFile_blob, blob, "f");
            this.id = (_b = metadata === null || metadata === void 0 ? void 0 : metadata.id) !== null && _b !== void 0 ? _b : "";
            this.url = (_c = metadata === null || metadata === void 0 ? void 0 : metadata.url) !== null && _c !== void 0 ? _c : "";
            this.name = (_e = (_d = metadata === null || metadata === void 0 ? void 0 : metadata.name) !== null && _d !== void 0 ? _d : __classPrivateFieldGet(_a, _a, "m", _AirplaneFile_extractName).call(_a, this.url)) !== null && _e !== void 0 ? _e : "";
            this.size = (_f = blob === null || blob === void 0 ? void 0 : blob.size) !== null && _f !== void 0 ? _f : 0;
            this.type = (_g = blob === null || blob === void 0 ? void 0 : blob.type) !== null && _g !== void 0 ? _g : "";
        }
        else {
            throw new Error("Expected either an Airplane file object or a Blob.");
        }
    }
    toJSON() {
        // We convert back to an AirplaneFileObject since that is how our API represents files.
        return {
            __airplaneType: "upload",
            id: this.id,
            url: this.url,
        };
    }
    /**
     * @returns a Promise that resolves with a string containing the contents of the AirplaneFile, interpreted as UTF-8.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Blob/text
     */
    async text() {
        const blob = await __classPrivateFieldGet(this, _AirplaneFile_instances, "m", _AirplaneFile_download).call(this);
        return blob.text();
    }
    /**
     * Similar to `text()`, except that it deserializes the contents as JSON. Throws an error if the contents are not valid JSON.
     * @returns a Promise that resolves with a JSON object representing the contents of the AirplaneFile, interpreted as UTF-8 and unmarshalled as JSON.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async json() {
        const text = await this.text();
        return JSON.parse(text);
    }
    /**
     * @returns a Promise that resolves with the contents of the AirplaneFile as binary data contained in an ArrayBuffer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer
     */
    async arrayBuffer() {
        const blob = await __classPrivateFieldGet(this, _AirplaneFile_instances, "m", _AirplaneFile_download).call(this);
        return blob.arrayBuffer();
    }
    /**
     * Downloads the contents of this file, if not already downloaded.
     *
     * AirplaneFiles are lazily-initialized so the file's contents are only downloaded upon request. This
     * method can be called to ensure that the file's contents have been downloaded which ensures that
     * values such as `type` or `size` will have been set.
     */
    async download() {
        await __classPrivateFieldGet(this, _AirplaneFile_instances, "m", _AirplaneFile_download).call(this);
    }
}
_a = AirplaneFile, _AirplaneFile_blob = new WeakMap(), _AirplaneFile_instances = new WeakSet(), _AirplaneFile_download = 
/**
 * Downloads the contents of this file, if not already downloaded.
 *
 * Unlike the public download() method, this returns the downloaded Blob
 * directly. This is used for type-safety to ensure #blob has been fetched.
 * @returns contents as a Blob.
 */
async function _AirplaneFile_download() {
    if (!__classPrivateFieldGet(this, _AirplaneFile_blob, "f")) {
        __classPrivateFieldSet(this, _AirplaneFile_blob, await getRuntime().fetchBlob(this.url), "f");
        this.type = __classPrivateFieldGet(this, _AirplaneFile_blob, "f").type;
        this.size = __classPrivateFieldGet(this, _AirplaneFile_blob, "f").size;
    }
    return __classPrivateFieldGet(this, _AirplaneFile_blob, "f");
}, _AirplaneFile_extractName = function _AirplaneFile_extractName(url) {
    if (!url) {
        return "";
    }
    // Extract the pathname from the URL. Note we can't use the URL global in the
    // workflows runtime.
    //
    // Remove the protocol.
    const u = url.replace(/^[a-z]+:\/\//, "");
    // Extract the final segment of the path.
    const segments = u.replace(/\/$/, "").replace(/\?.*/, "").split("/");
    if (segments.length <= 1) {
        // Do not return the first segment after the protocol (the domain).
        return "";
    }
    return segments === null || segments === void 0 ? void 0 : segments[segments.length - 1];
};
export const upload = async (payload, fileName) => {
    if (isBlob(payload)) {
        if (!fileName) {
            const extension = mime.getExtension(payload.type);
            if (!extension) {
                throw new Error(`Unable to determine file extension for payload, please specify a filename`);
            }
            fileName = `file.${extension}`;
        }
    }
    else {
        if (!fileName) {
            fileName = "file.txt";
        }
        payload = new Blob([payload], {
            type: "text/plain",
        });
    }
    const upload = await getRuntime().createUpload(fileName, payload.size);
    await getRuntime().uploadFileContents(upload.writeOnlyURL, payload);
    const file = {
        __airplaneType: "upload",
        id: upload.upload.id,
        url: upload.readOnlyURL,
    };
    return new AirplaneFile(file);
};
/**
 * @returns true if `b` is an instance of (or inherits from) the Blob class.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Blob
 */
const isBlob = (b) => {
    if (b == null || typeof b !== "object") {
        return false;
    }
    // Fallback to checking the object's StringTag to handle cases where Blob is not polyfilled.
    if (("Blob" in globalThis && b instanceof globalThis.Blob) || String(b) === "[object Blob]") {
        return true;
    }
    // Recursively check the object's prototype to see if it inherits from Blob.
    const prototype = Object.getPrototypeOf(b);
    return prototype ? isBlob(prototype) : false;
};
