import { deepEqual } from "fast-equals";
import { dedent } from "ts-dedent";
import { optionsToSchema } from "./options";
import { deserializeParamValues } from "../params/params_output";
import { serializeParams } from "../params/params_serialized";
import { getRuntime } from "../runtime";
/**
 * Prompts a user for confirmation without requiring parameters.
 * @param opts Configuration options.
 */
export const confirm = async (opts = {}) => {
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        description: opts.description ? dedent(opts.description) : undefined,
        notify: opts.notify,
    });
    await getRuntime().waitForPrompt(promptID);
    return;
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const text = async (name, opts = {}) => {
    const param = optionsToSchema(name, "shorttext", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    return values[param.slug];
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const longText = async (name, opts = {}) => {
    const param = optionsToSchema(name, "longtext", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    return values[param.slug];
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const sql = async (name, opts = {}) => {
    const param = optionsToSchema(name, "sql", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    return values[param.slug];
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const number = async (name, opts = {}) => {
    const param = optionsToSchema(name, "float", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    return values[param.slug];
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const integer = async (name, opts = {}) => {
    const param = optionsToSchema(name, "integer", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    return values[param.slug];
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const boolean = async (name, opts = {}) => {
    const param = optionsToSchema(name, "boolean", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    return values[param.slug];
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const date = async (name, opts = {}) => {
    const param = optionsToSchema(name, "date", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    // Convert back to Dates before passing back.
    return new Date(values[param.slug]);
};
/**
 * @deprecated since v0.2.23, use `prompt()` instead
 */
export const datetime = async (name, opts = {}) => {
    const param = optionsToSchema(name, "datetime", opts);
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    // Convert back to Dates before passing back.
    return new Date(values[param.slug]);
};
/**
 * Prompts a user to select one item from a list of options.
 * @param name The heading rendered above the parameter
 * @param options The list of possible options to select from. If empty and a selection is required, an error is thrown.
 * @param opts Additional configuration options
 * @returns The selected option
 * @example
 *   select("Slug", slugs, { description: "The slug to assign to the new team.", default: slugs[0] })
 * @example
 *   // Provide labels when working with a list of objects
 *   select("User", users, { optionToLabel: user => user.name })
 */
export const select = async (name, options, opts = {}) => {
    var _a;
    const optionToLabel = (_a = opts.optionToLabel) !== null && _a !== void 0 ? _a : ((option) => {
        switch (typeof option) {
            case "bigint":
            case "boolean":
            case "number":
                return String(option);
            case "string":
                return option;
        }
        if (option instanceof Date) {
            return option.toISOString();
        }
        return JSON.stringify(option);
    });
    const param = optionsToSchema(name, "integer", {
        ...opts,
        options: options.map((option, i) => ({ label: optionToLabel(option), value: i })),
        default: opts.default
            ? options.findIndex((option) => deepEqual(option, opts.default))
            : undefined,
    });
    if (options.length === 0 && !param.constraints.optional) {
        throw new Error(`The required prompt parameter, "${name}", has no options to select from.`);
    }
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: [param],
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        notify: opts.notify,
    });
    const values = await getRuntime().waitForPrompt(promptID);
    const i = values[param.slug];
    // TODO: update type system to handle optionals
    if (i == null) {
        throw new Error(`An option was not selected`);
    }
    return options[i];
};
/**
 * Prompts an operator for input.
 *
 * Each prompt contains a parameter form, similar to what you see when executing a task or runbook.
 * When a prompt is created, the run pauses⁠ and waits for a response⁠ before continuing.
 * By default, anyone who can access the associated run can also respond to the prompt,
 * but this can be restricted by specifying reviewers in the prompt's options. As a convenience,
 * you can use `prompt.confirm` to create prompts with no parameters.
 * @param params Defines the parameter form as a mapping of slug to parameter.
 * The values will be returned as an object that maps the parameter slug to the corresponding value.
 * To learn more about parameters, see the [Parameter documentation](https://docs.airplane.dev/platform/parameters).
 * @param opts Additional configuration options
 * @example
 *   // Prompt user to input a refund amount and reason.
 *   const { amount, reason } = await prompt(
 *     {
 *       amount: "integer",
 *       reason: "shorttext",
 *     },
 *     { confirmText: "Accept refund" }
 *   );
 * @example
 *   // Prompt with a list of options to choose from. As a convenience, you can use
 *   // `prompt.select` to create a prompt with a list of objects.
 *   const { username } = await prompt({
 *     username: {
 *       type: "shorttext",
 *       options: ["colin", "eric"],
 *     },
 *   });
 */
export const prompt = async (params, opts = {}) => {
    return await (await background(params, opts)).wait();
};
/**
 * Prompts an operator for input and does not wait for the prompt to be submitted. The prompt response
 * can be retrieved by calling `.wait()` on the returned object. As a convenience,
 * you can use `prompt()` to create a prompt and wait for a response.
 *
 * Each prompt contains a parameter form, similar to what you see when executing a task or runbook.
 * When a prompt is created, the run pauses⁠ and waits for a response⁠ before continuing.
 * By default, anyone who can access the associated run can also respond to the prompt,
 * but this can be restriced by specifying reviewers in the prompt's options.
 * @param params Defines the parameter form as a mapping of slug to parameter.
 * The values will be returned as an object that maps the parameter slug to the corresponding value.
 * To learn more about parameters, see the [Parameter documentation](https://docs.airplane.dev/platform/parameters).
 * @param opts Additional configuration options
 * @example
 *   // Prompt user to input a refund amount and reason.
 *   const prompt = await prompt.background(
 *     {
 *       amount: "integer",
 *       reason: "shorttext",
 *     },
 *     { confirmText: "Accept refund" }
 *   );
 *   const { amount, reason } = await prompt.wait();
 * @example
 *   // Prompt with a list of options to choose from.
 *   const prompt = await prompt.background({
 *     username: {
 *       type: "shorttext",
 *       options: ["colin", "eric"],
 *     },
 *   });
 *   const { username } = await prompt.wait();
 */
export const background = async (params, opts = {}) => {
    const promptID = await getRuntime().promptBackground({
        schema: {
            parameters: serializeParams(params),
        },
        reviewers: opts.reviewers,
        cancelText: opts.cancelText,
        confirmText: opts.confirmText,
        description: opts.description ? dedent(opts.description) : undefined,
        notify: opts.notify,
    });
    return new Prompt(params, promptID);
};
export class Prompt {
    constructor(params, promptID) {
        this.params = params;
        this.promptID = promptID;
        this.params = params;
        this.promptID = promptID;
    }
    /**
     * Waits on an operator for prompt input.
     * @example
     *   // Prompt user to input a refund amount and reason.
     *   const prompt = await airplane.prompt.background(
     *     {
     *       amount: "integer",
     *       reason: "shorttext",
     *     },
     *     { confirmText: "Accept refund" }
     *   );
     *   const { amount, reason } = await prompt.wait();
     */
    async wait() {
        const values = await getRuntime().waitForPrompt(this.promptID);
        return deserializeParamValues(this.params, values);
    }
    /**
     * Returns the user who submitted the prompt, if there is one.
     */
    async submitter() {
        const prompt = await getRuntime().getPrompt(this.promptID);
        if (prompt.submittedBy == null) {
            return undefined;
        }
        return await getRuntime().getUser(prompt.submittedBy);
    }
}
// Attach convenience methods for backwards compatibility.
prompt.text = text;
prompt.longText = longText;
prompt.sql = sql;
prompt.number = number;
prompt.integer = integer;
prompt.boolean = boolean;
prompt.date = date;
prompt.datetime = datetime;
prompt.confirm = confirm;
prompt.select = select;
prompt.background = background;
