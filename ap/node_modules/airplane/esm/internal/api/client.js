import { Fetcher, HTTPError } from "@airplane/lib";
import otel from "@opentelemetry/api";
import pkg from "../../package.json";
export class Client {
    constructor(opts = {}) {
        var _a;
        const env = (_a = globalThis.process) === null || _a === void 0 ? void 0 : _a.env;
        const host = opts.host || (env === null || env === void 0 ? void 0 : env.AIRPLANE_API_HOST) || "";
        const token = opts.token || (env === null || env === void 0 ? void 0 : env.AIRPLANE_TOKEN);
        const apiKey = opts.apiKey || (env === null || env === void 0 ? void 0 : env.AIRPLANE_API_KEY);
        const teamID = opts.teamID || (env === null || env === void 0 ? void 0 : env.AIRPLANE_TEAM_ID);
        const envID = opts.envID || (env === null || env === void 0 ? void 0 : env.AIRPLANE_ENV_ID);
        const envSlug = opts.envSlug || (env === null || env === void 0 ? void 0 : env.AIRPLANE_ENV_SLUG);
        const runID = opts.runID || (env === null || env === void 0 ? void 0 : env.AIRPLANE_RUN_ID);
        // The tokens below are not part of ClientOptions because they are Studio-specific
        // implementation details. The dev server uses the tunnel token to verify requests made to ngrok
        // tunnels, and this should not be exposed to users. This is set by the Studio at runtime.
        const tunnelToken = env === null || env === void 0 ? void 0 : env.AIRPLANE_TUNNEL_TOKEN;
        const sandboxToken = env === null || env === void 0 ? void 0 : env.AIRPLANE_SANDBOX_TOKEN;
        let headers = {};
        if (env === null || env === void 0 ? void 0 : env.AIRPLANE_API_HEADERS) {
            try {
                headers = JSON.parse(env.AIRPLANE_API_HEADERS);
            }
            catch (e) {
                // If we encounter a JSON parse error, ignore the value.
            }
        }
        if (opts.headers) {
            headers = { ...headers, ...opts.headers };
        }
        // Attempt to use self-hosted inputs if either an option is set,
        // the AIRPLANE_USE_SELF_HOSTED_INPUTS env var is set to true,
        // or the AP_AGENT_STORAGE_ZONE_SLUG is defined (meaning that we're
        // running in an agent environment with self-hosted storage).
        //
        // It's safe to have this true even if the team hasn't enabled
        // self-hosted inputs since we check in the Airplane API first
        // and revert back to Airplane-hosted inputs if needed.
        this.useSelfHostedInputs =
            opts.useSelfHostedInputs ||
                (env === null || env === void 0 ? void 0 : env.AIRPLANE_USE_SELF_HOSTED_INPUTS) === "true" ||
                !!(env === null || env === void 0 ? void 0 : env.AP_AGENT_STORAGE_ZONE_SLUG);
        this.agentStorageInternalHost =
            opts.agentStorageInternalHost || (env === null || env === void 0 ? void 0 : env.AP_AGENT_STORAGE_INTERNAL_HOST);
        // Use self-hosted outputs if both a zone slug and storage internal host are set.
        this.useSelfHostedOutputs =
            (opts.useSelfHostedOutputs || !!(env === null || env === void 0 ? void 0 : env.AP_AGENT_STORAGE_ZONE_SLUG)) &&
                !!this.agentStorageInternalHost;
        // Save the run ID since this is needed for some agent-storage-related calls.
        this.agentStorageRunID = runID;
        this.allowCachedMaxAge = opts.allowCachedMaxAge;
        this.fetcher = new Fetcher({
            host,
            token,
            apiKey,
            teamID,
            envID,
            envSlug,
            runID,
            tunnelToken,
            sandboxToken,
            source: opts === null || opts === void 0 ? void 0 : opts.source,
            headers,
            clientKind: "sdk/js",
            clientVersion: pkg.version,
        });
    }
    async executeTask(slug, paramValues, resources, opts = {}) {
        return this.useSelfHostedInputs
            ? this.executeTaskSelfHostedInputs(slug, paramValues, resources, opts)
            : this.executeTaskAirplane(slug, paramValues, resources, opts);
    }
    async executeTaskAirplane(slug, paramValues, resources, opts = {}) {
        const path = "/v0/tasks/execute";
        return this.withTracingPOST(path, async (headers) => {
            try {
                const { runID } = await this.fetcher.post(path, {
                    slug: slug,
                    paramValues: paramValues !== null && paramValues !== void 0 ? paramValues : {},
                    resources: resources !== null && resources !== void 0 ? resources : {},
                    allowCachedMaxAge: this.allowCachedMaxAge,
                }, {
                    abortSignal: opts.abortSignal,
                    idempotencyKey: opts.idempotencyKey,
                    headers,
                });
                return runID;
            }
            catch (e) {
                if (e instanceof HTTPError) {
                    if (e.statusCode >= 400 && e.statusCode <= 500) {
                        e.message = `Failed to execute task "${slug}": ${e.message}`;
                    }
                }
                throw e;
            }
        });
    }
    async executeTaskSelfHostedInputs(slug, paramValues, resources, opts = {}) {
        // Find the zone to create the inputs in.
        const pickZoneResp = await this.pickZone(slug);
        if (!pickZoneResp.zone) {
            return this.executeTaskAirplane(slug, paramValues, resources, opts);
        }
        // Create the inputs via the agent.
        const agentResp = await this.createSelfHostedInputs(paramValues, pickZoneResp.passthroughParams, pickZoneResp.constraintParams, pickZoneResp.parameters, pickZoneResp.zone.accessToken, pickZoneResp.zone.dataPlaneURL, slug, opts);
        // Create the run in the Airplane api.
        const airplanePath = "/v0/tasks/execute";
        return this.withTracingPOST(airplanePath, async (headers) => {
            var _a;
            try {
                const { runID } = await this.fetcher.post(airplanePath, {
                    slug: slug,
                    paramValues: agentResp.substituteValues,
                    resources: resources !== null && resources !== void 0 ? resources : {},
                    inputsZoneID: (_a = pickZoneResp.zone) === null || _a === void 0 ? void 0 : _a.id,
                    inputsZoneToken: agentResp.token,
                    allowCachedMaxAge: this.allowCachedMaxAge,
                }, {
                    abortSignal: opts.abortSignal,
                    idempotencyKey: opts.idempotencyKey,
                    headers,
                });
                return runID;
            }
            catch (e) {
                if (e instanceof HTTPError) {
                    if (e.statusCode >= 400 && e.statusCode <= 500) {
                        e.message = `Failed to execute task "${slug}": ${e.message}`;
                    }
                }
                throw e;
            }
        });
    }
    async executeRunbook(slug, paramValues, opts = {}) {
        const path = "/v0/runbooks/execute";
        return this.withTracingPOST(path, async (headers) => {
            const { sessionID } = await this.fetcher.post(path, {
                slug: slug,
                paramValues: paramValues !== null && paramValues !== void 0 ? paramValues : {},
            }, {
                abortSignal: opts.abortSignal,
                // Runbook execution is known to be a slow endpoint
                timeoutMs: 30 * 1000,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return sessionID;
        });
    }
    async getTaskReviewers(slug, opts = {}) {
        return await this.fetcher.get("/v0/tasks/getTaskReviewers", {
            taskSlug: slug,
        }, {
            abortSignal: opts.abortSignal,
        });
    }
    async createTaskRequest(triggerID, taskSlug, paramValues, reason, reviewers, opts = {}) {
        return this.useSelfHostedInputs
            ? this.createTaskRequestSelfHostedInputs(triggerID, taskSlug, paramValues, reason, reviewers, opts)
            : this.createTaskRequestAirplane(triggerID, paramValues, reason, reviewers, opts);
    }
    async createTaskRequestAirplane(triggerID, paramValues, reason, reviewers, opts = {}) {
        const path = "/v0/requests/create";
        return this.withTracingPOST(path, async (headers) => {
            const { triggerRequestID } = await this.fetcher.post(path, {
                triggerID,
                reason,
                reviewers,
                requestData: {
                    taskData: {
                        paramValues: paramValues,
                    },
                },
            }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return triggerRequestID;
        });
    }
    async createTaskRequestSelfHostedInputs(triggerID, taskSlug, paramValues, reason, reviewers, opts = {}) {
        // Find the zone to create the inputs in.
        const pickZoneResp = await this.pickZone(taskSlug);
        if (!pickZoneResp.zone) {
            return this.createTaskRequestAirplane(triggerID, paramValues, reason, reviewers, opts);
        }
        const agentResp = await this.createSelfHostedInputs(paramValues, pickZoneResp.passthroughParams, pickZoneResp.constraintParams, pickZoneResp.parameters, pickZoneResp.zone.accessToken, pickZoneResp.zone.dataPlaneURL, taskSlug, opts);
        const path = "/v0/requests/create";
        return this.withTracingPOST(path, async (headers) => {
            var _a;
            const { triggerRequestID } = await this.fetcher.post(path, {
                triggerID,
                reason,
                reviewers,
                requestData: {
                    taskData: {
                        paramValues: agentResp.substituteValues,
                        inputsZoneID: (_a = pickZoneResp.zone) === null || _a === void 0 ? void 0 : _a.id,
                        inputsZoneToken: agentResp.token,
                    },
                },
            }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return triggerRequestID;
        });
    }
    async createSelfHostedInputs(paramValues, passthroughParams, constraintParams, parameters, accessToken, dataPlaneURL, taskSlug, opts = {}) {
        const agentPath = "/v0/dp/inputs/create";
        return this.withTracingPOST(agentPath, async (headers) => {
            try {
                return await this.fetcher.post(agentPath, {
                    paramValues: paramValues !== null && paramValues !== void 0 ? paramValues : {},
                    passthroughParams,
                    constraintParams,
                    parameters,
                }, {
                    abortSignal: opts.abortSignal,
                    idempotencyKey: opts.idempotencyKey,
                    headers: {
                        ...headers,
                        "X-Airplane-Dataplane-Token": accessToken,
                    },
                    host: dataPlaneURL,
                });
            }
            catch (e) {
                if (e instanceof HTTPError) {
                    if (e.statusCode >= 400 && e.statusCode <= 500) {
                        e.message = `Failed to create self-hosted inputs for task ${taskSlug}: ${e.message}`;
                    }
                }
                throw e;
            }
        });
    }
    async getRunOutput(runID, opts = {}) {
        if (opts.useZone) {
            // We need to get the run zone, then use that to get the outputs since they're
            // not stored in the airplane API.
            //
            // TODO: Cache this so it's more efficient when there are many child runs.
            const zone = await this.getZoneByRunID(runID, { abortSignal: opts.abortSignal });
            const { output } = await this.fetcher.get("/v0/dp/runs/getOutputs", {
                runID,
            }, {
                abortSignal: opts.abortSignal,
                host: zone.dataPlaneURL,
                headers: {
                    "X-Airplane-Dataplane-Token": zone.accessToken,
                },
                // Longer timeout since fetching large run outputs takes a long time
                timeoutMs: 30 * 1000,
            });
            return output;
        }
        const { output } = await this.fetcher.get("/v0/runs/getOutputs", {
            id: runID,
        }, {
            abortSignal: opts.abortSignal,
            // Longer timeout since fetching large run outputs takes a long time
            timeoutMs: 30 * 1000,
        });
        return output;
    }
    async getRun(runID, opts = {}) {
        return this.fetcher.get("/v0/runs/get", { id: runID }, { abortSignal: opts.abortSignal });
    }
    async getZoneByRunID(runID, opts = {}) {
        return this.fetcher.get("/v0/runs/getZone", { id: runID }, { abortSignal: opts.abortSignal });
    }
    async getSession(sessionID, opts = {}) {
        return this.fetcher.get("/v0/sessions/get", { id: sessionID }, { abortSignal: opts.abortSignal });
    }
    async getTriggerRequest(triggerRequestID, opts = {}) {
        return this.fetcher.get("/v0/requests/get", { triggerRequestID }, { abortSignal: opts.abortSignal });
    }
    async createPrompt(prompt, opts = {}) {
        return this.useSelfHostedOutputs
            ? this.createPromptSelfHostedOutputs(prompt, opts)
            : this.createPromptAirplane(prompt, opts);
    }
    async createPromptAirplane(prompt, opts = {}) {
        const path = "/v0/prompts/create";
        return this.withTracingPOST(path, async (headers) => {
            const resp = await this.fetcher.post(path, prompt, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return resp.id;
        });
    }
    async createPromptSelfHostedOutputs(prompt, opts = {}) {
        const agentPath = "/v0/dp/prompts/create";
        const apiPath = "/v0/prompts/create";
        return this.withTracingPOST(agentPath, async (headers) => {
            // First, save the prompt in the agent server
            const agentResp = await this.fetcher.post(agentPath, {
                runID: this.agentStorageRunID,
                schema: prompt.schema,
                description: prompt.description,
                confirmText: prompt.confirmText,
                cancelText: prompt.cancelText,
            }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
                host: this.agentStorageInternalHost,
            });
            // Then, save it in the API with a placeholder value
            const apiResp = await this.fetcher.post(apiPath, {
                schema: agentResp.placeholderSchema,
                description: agentResp.placeholderDescription,
                confirmText: agentResp.placeholderConfirmText,
                cancelText: agentResp.placeholderCancelText,
                reviewers: prompt.reviewers,
                notify: prompt.notify,
                zoneToken: agentResp.token,
            }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return apiResp.id;
        });
    }
    async createSleep(sleep, opts = {}) {
        const path = "/v0/sleeps/create";
        return this.withTracingPOST(path, async (headers) => {
            const resp = await this.fetcher.post(path, sleep, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return resp.id;
        });
    }
    async getSleep(id, opts = {}) {
        const resp = await this.fetcher.get("/v0/sleeps/get", { id }, {
            abortSignal: opts.abortSignal,
        });
        return resp;
    }
    async createDisplay(display, opts = {}) {
        return this.useSelfHostedOutputs
            ? this.createDisplaySelfHostedOutputs(display, opts)
            : this.createDisplayAirplane(display, opts);
    }
    async createDisplayAirplane(display, opts = {}) {
        const path = "/v0/displays/create";
        return this.withTracingPOST(path, async (headers) => {
            const resp = await this.fetcher.post(path, { display }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return resp.id;
        });
    }
    async createDisplaySelfHostedOutputs(display, opts = {}) {
        const agentPath = "/v0/dp/displays/create";
        const apiPath = "/v0/displays/create";
        return this.withTracingPOST(agentPath, async (headers) => {
            // First, save the display in the agent server
            const agentResp = await this.fetcher.post(agentPath, { runID: this.agentStorageRunID, display }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
                host: this.agentStorageInternalHost,
            });
            // Then, save it in the API with a placeholder value
            const apiResp = await this.fetcher.post(apiPath, { display: agentResp.placeholder, zoneToken: agentResp.token }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return apiResp.id;
        });
    }
    async createUpload(fileName, sizeBytes, opts = {}) {
        return this.useSelfHostedInputs
            ? this.createUploadSelfHostedInputs(fileName, sizeBytes, opts)
            : this.createUploadAirplane(fileName, sizeBytes, opts);
    }
    async createUploadAirplane(fileName, sizeBytes, opts = {}) {
        const path = "/v0/uploads/create";
        return this.withTracingPOST(path, async (headers) => {
            const resp = await this.fetcher.post(path, { fileName, sizeBytes }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
            return resp;
        });
    }
    async createUploadSelfHostedInputs(fileName, sizeBytes, opts = {}) {
        // Find the zone to create the upload in.
        const pickZoneResp = await this.pickZone();
        if (!pickZoneResp.zone) {
            return this.createUploadAirplane(fileName, sizeBytes, opts);
        }
        // Create the upload via the agent.
        const agentPath = "/v0/dp/uploads/create";
        const agentResp = await this.withTracingPOST(agentPath, async (headers) => {
            var _a, _b;
            return await this.fetcher.post(agentPath, { fileName, sizeBytes }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers: {
                    ...headers,
                    "X-Airplane-Dataplane-Token": (_a = pickZoneResp.zone) === null || _a === void 0 ? void 0 : _a.accessToken,
                },
                host: (_b = pickZoneResp.zone) === null || _b === void 0 ? void 0 : _b.dataPlaneURL,
            });
        });
        const airplanePath = "/v0/uploads/create";
        const airplaneResp = await this.withTracingPOST(airplanePath, async (headers) => {
            var _a;
            return await this.fetcher.post(airplanePath, {
                fileName,
                sizeBytes,
                zoneID: (_a = pickZoneResp.zone) === null || _a === void 0 ? void 0 : _a.id,
                zoneToken: agentResp.upload.zoneToken,
            }, {
                abortSignal: opts.abortSignal,
                idempotencyKey: opts.idempotencyKey,
                headers,
            });
        });
        return {
            upload: airplaneResp.upload,
            readOnlyURL: agentResp.readOnlyURL,
            writeOnlyURL: agentResp.writeOnlyURL,
        };
    }
    async uploadFileContents(url, payload, opts = {}) {
        var _a, _b;
        const controller = new AbortController();
        const onAbort = () => {
            var _a;
            controller.abort();
            (_a = opts.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", onAbort);
        };
        // If the abortSignal fires, cancel the AbortController in order to cancel the fetch request.
        (_a = opts.abortSignal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", onAbort);
        // If the abortSignal has already fired, ensure the controller is also marked as aborted
        // so that the request immediately aborts.
        if ((_b = opts.abortSignal) === null || _b === void 0 ? void 0 : _b.aborted) {
            onAbort();
        }
        // Abort the request if it takes longer than a minute.
        const timeout = setTimeout(() => controller.abort(), 60 * 1000);
        try {
            const parsedURL = new URL(url);
            const headers = parsedURL.hostname.endsWith("windows.net")
                ? { "x-ms-blob-type": "BlockBlob" }
                : { "X-Goog-Content-Length-Range": `0,${payload.size}` };
            await fetch(url, {
                method: "PUT",
                headers,
                body: payload,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                signal: controller.signal,
            });
        }
        finally {
            clearTimeout(timeout);
        }
    }
    async getPrompt(id, opts = {}) {
        // Get the prompt from the API
        const apiResp = await this.fetcher.get("/v0/prompts/get", { id }, { abortSignal: opts.abortSignal });
        if (apiResp.prompt.zoneToken) {
            // There's a zone token set, so use that to get the real schema and values
            const agentResp = await this.fetcher.get("/v0/dp/prompts/get", { promptToken: apiResp.prompt.zoneToken, runID: this.agentStorageRunID }, { abortSignal: opts.abortSignal, host: this.agentStorageInternalHost });
            return {
                id: apiResp.prompt.id,
                schema: agentResp.promptData.schema,
                values: agentResp.promptData.values,
                submittedAt: apiResp.prompt.submittedAt,
                submittedBy: apiResp.prompt.submittedBy,
                cancelledAt: apiResp.prompt.cancelledAt,
                cancelledBy: apiResp.prompt.cancelledBy,
                zoneToken: apiResp.prompt.zoneToken,
            };
        }
        return apiResp.prompt;
    }
    async getUser(id, opts = {}) {
        const resp = await this.fetcher.get("/v0/users/get", { userID: id }, { abortSignal: opts.abortSignal });
        return resp.user;
    }
    async generateIDToken(audience, opts = {}) {
        const resp = await this.fetcher.post("/v0/oidc/generateIDToken", { audience }, { abortSignal: opts.abortSignal });
        return resp.token;
    }
    async pickZone(slug) {
        var _a, _b, _c, _d;
        const args = slug
            ? { taskSlug: slug }
            : ((_b = (_a = globalThis.process) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.AIRPLANE_TASK_REVISION_ID)
                ? { taskRevisionID: (_d = (_c = globalThis.process) === null || _c === void 0 ? void 0 : _c.env) === null || _d === void 0 ? void 0 : _d.AIRPLANE_TASK_REVISION_ID }
                : {};
        return await this.fetcher.get("/v0/inputs/pickZone", args);
    }
    async withTracingPOST(path, f) {
        const tracer = otel.trace.getTracer("js-sdk", pkg.version);
        return await tracer.startActiveSpan(`fetcher.post`, async (span) => {
            span.setAttribute("http_route", path);
            span.setAttribute("http_method", "post");
            // Attach trace context headers onto `headers`. See
            // https://www.w3.org/TR/trace-context/ for more details.
            const headers = {};
            otel.propagation.inject(otel.context.active(), headers);
            try {
                return await f(headers);
            }
            finally {
                span.end();
            }
        });
    }
}
