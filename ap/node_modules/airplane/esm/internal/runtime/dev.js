import { setTimeoutWithCancel } from "@airplane/lib";
import { runtime as standardRuntime } from "./standard";
import { Client } from "../api/client";
import { Poller } from "../api/poller";
import { calculateEndTimeISOString } from "../sleep/utils";
export const runtime = {
    execute: async (slug, paramValues = {}, resources, opts = {}) => {
        return standardRuntime.execute(slug, paramValues, resources, opts);
    },
    executeBackground: async (slug, paramValues = {}, resources, opts = {}) => {
        return standardRuntime.executeBackground(slug, paramValues, resources, opts);
    },
    executeRunbook: async (slug, paramValues = {}, opts = {}) => {
        return standardRuntime.executeRunbook(slug, paramValues, opts);
    },
    executeRunbookBackground: async (slug, paramValues, opts) => {
        return standardRuntime.executeRunbookBackground(slug, paramValues, opts);
    },
    promptBackground: async (prompt) => {
        return standardRuntime.promptBackground(prompt);
    },
    waitForPrompt: async (promptID) => {
        return standardRuntime.waitForPrompt(promptID);
    },
    display: async (display) => {
        await standardRuntime.display(display);
    },
    sleep: async (duration) => {
        const client = new Client();
        const now = new Date();
        const sleepID = await client.createSleep({
            durationMs: duration,
            until: calculateEndTimeISOString(now.getTime(), duration),
        });
        let isSleepFinished = false;
        // Create an AbortController to cancel the sleep if it is skipped.
        const controller = new AbortController();
        const localSleep = async () => {
            await setTimeoutWithCancel(duration, controller);
            isSleepFinished = true;
        };
        const checkSkip = async (id) => {
            const poller = new Poller({ delayMs: 500 });
            await poller.run(async () => {
                if (isSleepFinished) {
                    return true;
                }
                const sleep = await client.getSleep(id);
                if (sleep.skippedAt !== null) {
                    // Abort the timeout if the sleep was skipped.
                    controller.abort();
                    return true;
                }
                return null;
            });
        };
        // Wait for either the sleep to finish or for the sleep to be skipped.
        await Promise.all([localSleep(), checkSkip(sleepID)]);
    },
    getPrompt: async (promptID) => {
        return await standardRuntime.getPrompt(promptID);
    },
    getUser: async (userID) => {
        return await standardRuntime.getUser(userID);
    },
    logChunks: (output) => {
        standardRuntime.logChunks(output);
    },
    fetchBlob: async (url) => {
        return standardRuntime.fetchBlob(url);
    },
    createUpload: async (fileName, sizeBytes) => {
        return standardRuntime.createUpload(fileName, sizeBytes);
    },
    uploadFileContents: async (url, payload) => {
        return standardRuntime.uploadFileContents(url, payload);
    },
    generateIDToken: async (audience) => {
        return standardRuntime.generateIDToken(audience);
    },
};
