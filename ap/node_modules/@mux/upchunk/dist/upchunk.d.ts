import type { XhrHeaders, XhrResponse } from 'xhr';
export declare const isValidChunkSize: (chunkSize: any, { minChunkSize, maxChunkSize, }?: {
    minChunkSize?: number | undefined;
    maxChunkSize?: number | undefined;
}) => chunkSize is number | null | undefined;
export declare const getChunkSizeError: (chunkSize: any, { minChunkSize, maxChunkSize, }?: {
    minChunkSize?: number | undefined;
    maxChunkSize?: number | undefined;
}) => TypeError;
export declare type ChunkedStreamIterableOptions = {
    defaultChunkSize?: number;
    minChunkSize?: number;
    maxChunkSize?: number;
};
export declare class ChunkedStreamIterable implements AsyncIterable<Blob> {
    protected readableStream: ReadableStream<Uint8Array | Blob>;
    protected _chunkSize: number | undefined;
    protected defaultChunkSize: number;
    readonly minChunkSize: number;
    readonly maxChunkSize: number;
    constructor(readableStream: ReadableStream<Uint8Array | Blob>, options?: ChunkedStreamIterableOptions);
    get chunkSize(): number;
    set chunkSize(value: number);
    get chunkByteSize(): number;
    [Symbol.asyncIterator](): AsyncIterator<Blob>;
}
declare type EventName = 'attempt' | 'attemptFailure' | 'chunkSuccess' | 'error' | 'offline' | 'online' | 'progress' | 'success';
declare type AllowedMethods = 'PUT' | 'POST' | 'PATCH';
export interface UpChunkOptions {
    endpoint: string | ((file?: File) => Promise<string>);
    file: File;
    method?: AllowedMethods;
    headers?: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);
    maxFileSize?: number;
    chunkSize?: number;
    attempts?: number;
    delayBeforeAttempt?: number;
    retryCodes?: number[];
    dynamicChunkSize?: boolean;
    maxChunkSize?: number;
    minChunkSize?: number;
}
export declare class UpChunk {
    static createUpload(options: UpChunkOptions): UpChunk;
    endpoint: string | ((file?: File) => Promise<string>);
    file: File;
    headers: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);
    method: AllowedMethods;
    attempts: number;
    delayBeforeAttempt: number;
    retryCodes: number[];
    dynamicChunkSize: boolean;
    protected chunkedStreamIterable: ChunkedStreamIterable;
    protected chunkedStreamIterator: AsyncIterator<Blob, any, undefined>;
    protected pendingChunk?: Blob;
    private chunkCount;
    private maxFileBytes;
    private endpointValue;
    private totalChunks;
    private attemptCount;
    private offline;
    private _paused;
    private success;
    private currentXhr?;
    private lastChunkStart;
    private nextChunkRangeStart;
    private eventTarget;
    constructor(options: UpChunkOptions);
    protected get maxChunkSize(): number;
    protected get minChunkSize(): number;
    get chunkSize(): number;
    set chunkSize(value: number);
    get chunkByteSize(): number;
    get totalChunkSize(): number;
    /**
     * Subscribe to an event
     */
    on(eventName: EventName, fn: (event: CustomEvent) => void): void;
    /**
     * Subscribe to an event once
     */
    once(eventName: EventName, fn: (event: CustomEvent) => void): void;
    /**
     * Unsubscribe to an event
     */
    off(eventName: EventName, fn: (event: CustomEvent) => void): void;
    get paused(): boolean;
    abort(): void;
    pause(): void;
    resume(): void;
    /**
     * Dispatch an event
     */
    private dispatch;
    /**
     * Validate options and throw errors if expectations are violated.
     */
    private validateOptions;
    /**
     * Endpoint can either be a URL or a function that returns a promise that resolves to a string.
     */
    private getEndpoint;
    private xhrPromise;
    /**
     * Send chunk of the file with appropriate headers
     */
    protected sendChunk(chunk: Blob): Promise<XhrResponse>;
    protected sendChunkWithRetries(chunk: Blob): Promise<boolean>;
    /**
     * Manage the whole upload by calling getChunk & sendChunk
     * handle errors & retries and dispatch events
     */
    private sendChunks;
}
export declare function createUpload(options: UpChunkOptions): UpChunk;
export {};
