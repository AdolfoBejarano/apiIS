import { executeBackgroundWithCacheInfo, RunTerminationError } from "airplane";
import { getRun } from "airplane/api";
import dayjs from "dayjs";
import hash from "object-hash";
import { isGenericExecuteError } from "./status.js";
import { MISSING_EXECUTE_PERMISSIONS_ERROR_PREFIX } from "../errors/formatErrors.js";
import { sendViewMessage } from "../message/sendViewMessage.js";
import { getExecuteOptions } from "./env.js";
const executeTask = async (slug, executeType, params, runID, allowCachedMaxAge) => {
  try {
    const executeOptions = getExecuteOptions(executeType, allowCachedMaxAge);
    let executedRunID = runID ?? "";
    if (!executedRunID) {
      const resp = await executeBackgroundWithCacheInfo(slug, params, executeOptions);
      executedRunID = resp.runID;
      const cacheFetchedAt = resp.isCached ? dayjs().toISOString() : void 0;
      sendViewMessage({
        type: "start_run",
        runID: executedRunID,
        isCached: resp.isCached,
        cacheFetchedAt,
        executeType
      });
    }
    const checkRun = async () => {
      const run = await getRun(executedRunID, executeOptions);
      if (run.status === "Failed" || run.status === "Cancelled") {
        throw new RunTerminationError(run);
      }
      if (run.status !== "Succeeded") {
        return null;
      }
      return {
        output: run.output,
        runID: run.id
      };
    };
    const output = await new Promise((resolve, reject) => {
      const fnw = async () => {
        try {
          const out = await checkRun();
          if (out !== null) {
            return resolve(out);
          }
        } catch (err) {
          return reject(err);
        }
        setTimeout(fnw, 500);
      };
      fnw();
    });
    return output;
  } catch (e) {
    return handleExecutionError(e, slug);
  }
};
const executeTaskBackground = async (slug, executeType, params, allowCachedMaxAge) => {
  try {
    const executeOptions = getExecuteOptions(executeType, allowCachedMaxAge);
    const resp = await executeBackgroundWithCacheInfo(slug, params, executeOptions);
    const cacheFetchedAt = resp.isCached ? dayjs().toISOString() : void 0;
    sendViewMessage({
      type: "start_run",
      runID: resp.runID,
      isCached: resp.isCached,
      cacheFetchedAt,
      executeType
    });
    return resp.runID;
  } catch (e) {
    return handleExecutionError(e, slug);
  }
};
const handleExecutionError = (e, slug) => {
  if (isRunTerminationError(e)) {
    return {
      error: {
        message: e.message,
        type: "FAILED"
      },
      output: e.run.output,
      runID: e.run.id
    };
  } else if (isGenericExecuteError(e)) {
    if (e.statusCode === 403) {
      return {
        error: {
          message: `${MISSING_EXECUTE_PERMISSIONS_ERROR_PREFIX} ${slug}`,
          type: "AIRPLANE_INTERNAL"
        }
      };
    } else if (e.statusCode >= 400 && e.statusCode < 500) {
      sendViewMessage({
        type: "console",
        messageType: "error",
        message: e.message,
        taskSlug: slug,
        hash: hash(e),
        time: Date.now()
      });
      return {
        error: {
          message: e.message,
          type: "CLIENT_ERROR"
        }
      };
    } else {
      sendViewMessage({
        type: "console",
        messageType: "error",
        message: e.message,
        taskSlug: slug,
        hash: hash(e),
        time: Date.now()
      });
      return {
        error: {
          message: e.message,
          type: "AIRPLANE_INTERNAL"
        }
      };
    }
  } else {
    const message = "An error occured";
    sendViewMessage({
      type: "console",
      messageType: "error",
      message,
      taskSlug: slug,
      hash: hash(message),
      time: Date.now()
    });
    return {
      error: {
        message,
        type: "AIRPLANE_INTERNAL"
      }
    };
  }
};
const isRunTerminationError = (x) => {
  return typeof x.message === "string" && "run" in x;
};
function isExecuteTaskError(value) {
  return !!value.error;
}
export {
  executeTask,
  executeTaskBackground,
  isExecuteTaskError
};
//# sourceMappingURL=executeTask.js.map
