{"version":3,"file":"executeTask.js","sources":["../../src/client/executeTask.ts"],"sourcesContent":["import { RunTerminationError, executeBackgroundWithCacheInfo } from \"airplane\";\nimport { getRun } from \"airplane/api\";\nimport type { ParamValues, Run } from \"airplane/api\";\nimport dayjs from \"dayjs\";\nimport hash from \"object-hash\";\n\nimport { isGenericExecuteError } from \"client/status\";\nimport type { ExecuteError } from \"components/query\";\nimport { MISSING_EXECUTE_PERMISSIONS_ERROR_PREFIX } from \"errors/formatErrors\";\nimport { sendViewMessage } from \"message/sendViewMessage\";\n\nimport { getExecuteOptions } from \"./env\";\n\nexport type ExecuteTaskSuccess<TOutput = Record<string, unknown>> = {\n  output: TOutput;\n  runID: string;\n};\nexport type ExecuteTaskError<TOutput = Record<string, unknown>> = {\n  output?: TOutput;\n  error: ExecuteError;\n  runID?: string;\n};\nexport type ExecuteTaskResult<TOutput = Record<string, unknown>> =\n  | ExecuteTaskSuccess<TOutput>\n  | ExecuteTaskError<TOutput>;\n\nexport { ParamValues };\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type DefaultParams = Record<string, any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type DefaultOutput = any;\n\nexport const executeTask = async <\n  TParams extends ParamValues | undefined = ParamValues,\n  TOutput = Record<string, unknown>,\n>(\n  slug: string,\n  executeType: \"query\" | \"mutation\",\n  params?: TParams,\n  /** Including this indicates that the caller already executed the task and this function does not have to do the initial execution. */\n  runID?: string,\n  allowCachedMaxAge?: number,\n): Promise<ExecuteTaskResult<TOutput>> => {\n  try {\n    const executeOptions = getExecuteOptions(executeType, allowCachedMaxAge);\n    let executedRunID = runID ?? \"\";\n    if (!executedRunID) {\n      const resp = await executeBackgroundWithCacheInfo(\n        slug,\n        params,\n        executeOptions,\n      );\n      executedRunID = resp.runID;\n      const cacheFetchedAt = resp.isCached ? dayjs().toISOString() : undefined;\n\n      sendViewMessage({\n        type: \"start_run\",\n        runID: executedRunID,\n        isCached: resp.isCached,\n        cacheFetchedAt,\n        executeType,\n      });\n    }\n\n    const checkRun = async () => {\n      const run = await getRun<DefaultParams, TOutput>(\n        executedRunID,\n        executeOptions,\n      );\n      if (run.status === \"Failed\" || run.status === \"Cancelled\") {\n        throw new RunTerminationError(run);\n      }\n      if (run.status !== \"Succeeded\") {\n        return null;\n      }\n      return {\n        output: run.output,\n        runID: run.id,\n      };\n    };\n    // Poll until the run terminates:\n    const output = await new Promise<ExecuteTaskResult<TOutput>>(\n      (resolve, reject) => {\n        const fnw = async () => {\n          try {\n            const out = await checkRun();\n            if (out !== null) {\n              return resolve(out);\n            }\n          } catch (err) {\n            return reject(err);\n          }\n\n          setTimeout(fnw, 500);\n        };\n        fnw();\n      },\n    );\n    return output;\n  } catch (e) {\n    return handleExecutionError<TOutput>(e, slug);\n  }\n};\n\n/** Execute the task but don't want for the run to complete. */\nexport const executeTaskBackground = async <\n  TParams extends ParamValues | undefined = ParamValues,\n  TOutput = Record<string, unknown>,\n>(\n  slug: string,\n  executeType: \"query\" | \"mutation\",\n  params?: TParams,\n  allowCachedMaxAge?: number,\n): Promise<ExecuteTaskError<TOutput> | string> => {\n  try {\n    const executeOptions = getExecuteOptions(executeType, allowCachedMaxAge);\n    const resp = await executeBackgroundWithCacheInfo(\n      slug,\n      params,\n      executeOptions,\n    );\n    const cacheFetchedAt = resp.isCached ? dayjs().toISOString() : undefined;\n\n    sendViewMessage({\n      type: \"start_run\",\n      runID: resp.runID,\n      isCached: resp.isCached,\n      cacheFetchedAt,\n      executeType,\n    });\n\n    return resp.runID;\n  } catch (e) {\n    return handleExecutionError<TOutput>(e, slug);\n  }\n};\n\nconst handleExecutionError = <TOutput>(\n  e: unknown,\n  slug: string,\n): ExecuteTaskError<TOutput> => {\n  if (isRunTerminationError<TOutput>(e)) {\n    return {\n      error: { message: e.message, type: \"FAILED\" },\n      output: e.run.output,\n      runID: e.run.id,\n    };\n  } else if (isGenericExecuteError(e)) {\n    if (e.statusCode === 403) {\n      return {\n        error: {\n          message: `${MISSING_EXECUTE_PERMISSIONS_ERROR_PREFIX} ${slug}`,\n          type: \"AIRPLANE_INTERNAL\",\n        },\n      };\n    } else if (e.statusCode >= 400 && e.statusCode < 500) {\n      sendViewMessage({\n        type: \"console\",\n        messageType: \"error\",\n        message: e.message,\n        taskSlug: slug,\n        hash: hash(e),\n        time: Date.now(),\n      });\n      return {\n        error: {\n          message: e.message,\n          type: \"CLIENT_ERROR\",\n        },\n      };\n    } else {\n      sendViewMessage({\n        type: \"console\",\n        messageType: \"error\",\n        message: e.message,\n        taskSlug: slug,\n        hash: hash(e),\n        time: Date.now(),\n      });\n      return {\n        error: { message: e.message, type: \"AIRPLANE_INTERNAL\" },\n      };\n    }\n  } else {\n    const message = \"An error occured\";\n    sendViewMessage({\n      type: \"console\",\n      messageType: \"error\",\n      message,\n      taskSlug: slug,\n      hash: hash(message),\n      time: Date.now(),\n    });\n    return {\n      error: { message, type: \"AIRPLANE_INTERNAL\" },\n    };\n  }\n};\n\ninterface RunTerminationErrorIface<TOutput = Record<string, unknown>> {\n  message: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  run: Run<any, TOutput>;\n}\n\nconst isRunTerminationError = <TOutput = Record<string, unknown>>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  x: any,\n): x is RunTerminationErrorIface<TOutput> => {\n  return typeof x.message === \"string\" && \"run\" in x;\n};\n\nexport function isExecuteTaskError<TOutput>(\n  value: ExecuteTaskResult<TOutput>,\n): value is ExecuteTaskError<TOutput> {\n  return !!(value as ExecuteTaskError).error;\n}\n"],"names":["executeTask","slug","executeType","params","runID","allowCachedMaxAge","executeOptions","getExecuteOptions","executedRunID","resp","executeBackgroundWithCacheInfo","cacheFetchedAt","isCached","dayjs","toISOString","undefined","type","checkRun","run","getRun","status","RunTerminationError","output","id","Promise","resolve","reject","fnw","out","err","setTimeout","e","handleExecutionError","executeTaskBackground","isRunTerminationError","error","message","isGenericExecuteError","statusCode","MISSING_EXECUTE_PERMISSIONS_ERROR_PREFIX","messageType","taskSlug","hash","time","Date","now","x","isExecuteTaskError","value"],"mappings":"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"}