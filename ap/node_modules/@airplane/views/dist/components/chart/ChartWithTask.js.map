{"version":3,"file":"ChartWithTask.js","sources":["../../../src/components/chart/ChartWithTask.tsx"],"sourcesContent":["import { useMemo } from \"react\";\n\nimport { DefaultOutput, DefaultParams, ParamValues } from \"client\";\nimport {\n  SetLatestRunProps,\n  useSetLatestRunInTaskQuery,\n} from \"components/errorBoundary/LatestRunDetails\";\nimport { displayTaskBackedError } from \"errors/displayTaskBackedError\";\nimport { useTaskQuery } from \"state\";\n\nimport {\n  ConnectedChartProps,\n  ChartProps,\n  ChartWithTaskProps,\n} from \"./Chart.types\";\nimport { ConnectedChart } from \"./ConnectedChart\";\n\nexport const ChartWithTask = <\n  TParams extends ParamValues | undefined = DefaultParams,\n  TOutput = DefaultOutput,\n>({\n  outputTransform,\n  task,\n  setLatestRun,\n  ...chartProps\n}: ChartWithTaskProps<TParams, TOutput> & SetLatestRunProps) => {\n  const fullQuery = useSetLatestRunInTaskQuery<TParams>(task, setLatestRun);\n  const { error, loading, output, runID } = useTaskQuery<TParams, TOutput>(\n    fullQuery,\n  );\n  const data = useOutputToData(output, outputTransform);\n\n  if (error) {\n    return displayTaskBackedError({\n      error,\n      taskSlug: fullQuery.slug,\n      runID,\n      componentName: \"Chart\",\n    });\n  } else {\n    return (\n      <ConnectedChart {...chartProps} data={data ?? []} loading={loading} />\n    );\n  }\n};\n\nexport function doesUseTask<TParams extends ParamValues | undefined, TOutput>(\n  props: ChartProps<TParams, TOutput>,\n): props is ChartWithTaskProps<TParams, TOutput> {\n  return Boolean((props as ChartWithTaskProps<TParams, TOutput>).task);\n}\n\nfunction useOutputToData<\n  TParams extends ParamValues | undefined = DefaultParams,\n  TOutput = DefaultOutput,\n>(\n  output?: TOutput,\n  outputTransform?: ChartWithTaskProps<TParams, TOutput>[\"outputTransform\"],\n): ConnectedChartProps[\"data\"] {\n  return useMemo(() => {\n    if (!output) return [];\n    // We try unwrapping only if the output is of the form\n    // { Q1: ... }, as a convenience method for dealing with SQL builtins.\n    const unwrapQ1 = (output: TOutput) => {\n      if (\n        output &&\n        !Array.isArray(output) &&\n        typeof output === \"object\" &&\n        Object.keys(output).length === 1 &&\n        Object.keys(output)[0] === \"Q1\"\n      ) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (output as Record<string, any>)[\"Q1\"];\n      }\n      return output;\n    };\n\n    const unwrappedOutput = unwrapQ1(output);\n    if (outputTransform) {\n      return outputTransform(unwrappedOutput);\n    }\n    return unwrappedOutput;\n  }, [output, outputTransform]);\n}\n"],"names":["ChartWithTask","outputTransform","task","setLatestRun","chartProps","fullQuery","useSetLatestRunInTaskQuery","error","loading","output","runID","useTaskQuery","data","useOutputToData","displayTaskBackedError","taskSlug","slug","componentName","doesUseTask","props","Boolean","useMemo","unwrapQ1","Array","isArray","Object","keys","length","unwrappedOutput"],"mappings":";;;;;;AAiBO,MAAMA,gBAAgB,CAG3B;AAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACA,GAAGC;AACqD,MAAM;AACxDC,QAAAA,YAAYC,2BAAoCJ,MAAMC,YAAY;AAClE,QAAA;AAAA,IAAEI;AAAAA,IAAOC;AAAAA,IAASC;AAAAA,IAAQC;AAAAA,EAAAA,IAAUC,aACxCN,SACF;AACMO,QAAAA,OAAOC,gBAAgBJ,QAAQR,eAAe;AAEpD,MAAIM,OAAO;AACT,WAAOO,uBAAuB;AAAA,MAC5BP;AAAAA,MACAQ,UAAUV,UAAUW;AAAAA,MACpBN;AAAAA,MACAO,eAAe;AAAA,IAAA,CAChB;AAAA,EAAA,OACI;AAEH,WAAA,oBAAC,kBAAe,GAAIb,YAAY,MAAMQ,QAAQ,CAAA,GAAI,QAAoB,CAAA;AAAA,EAE1E;AACF;AAEO,SAASM,YACdC,OAC+C;AACxCC,SAAAA,QAASD,MAA+CjB,IAAI;AACrE;AAEA,SAASW,gBAIPJ,QACAR,iBAC6B;AAC7B,SAAOoB,QAAQ,MAAM;AACnB,QAAI,CAACZ;AAAQ,aAAO;AAGda,UAAAA,WAAWA,CAACb,YAAoB;AAElCA,UAAAA,WACA,CAACc,MAAMC,QAAQf,OAAM,KACrB,OAAOA,YAAW,YAClBgB,OAAOC,KAAKjB,OAAM,EAAEkB,WAAW,KAC/BF,OAAOC,KAAKjB,OAAM,EAAE,CAAC,MAAM,MAC3B;AAEA,eAAQA,QAA+B,IAAI;AAAA,MAC7C;AACOA,aAAAA;AAAAA,IAAAA;AAGHmB,UAAAA,kBAAkBN,SAASb,MAAM;AACvC,QAAIR,iBAAiB;AACnB,aAAOA,gBAAgB2B,eAAe;AAAA,IACxC;AACOA,WAAAA;AAAAA,EAAAA,GACN,CAACnB,QAAQR,eAAe,CAAC;AAC9B;"}