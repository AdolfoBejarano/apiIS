import { jsx } from "react/jsx-runtime";
import { useMemo } from "react";
import { useSetLatestRunInTaskQuery } from "../errorBoundary/LatestRunDetails.js";
import { displayTaskBackedError } from "../../errors/displayTaskBackedError.js";
import { ConnectedChart } from "./ConnectedChart.js";
import { useTaskQuery } from "../../state/tasks/useTaskQuery.js";
const ChartWithTask = ({
  outputTransform,
  task,
  setLatestRun,
  ...chartProps
}) => {
  const fullQuery = useSetLatestRunInTaskQuery(task, setLatestRun);
  const {
    error,
    loading,
    output,
    runID
  } = useTaskQuery(fullQuery);
  const data = useOutputToData(output, outputTransform);
  if (error) {
    return displayTaskBackedError({
      error,
      taskSlug: fullQuery.slug,
      runID,
      componentName: "Chart"
    });
  } else {
    return /* @__PURE__ */ jsx(ConnectedChart, { ...chartProps, data: data ?? [], loading });
  }
};
function doesUseTask(props) {
  return Boolean(props.task);
}
function useOutputToData(output, outputTransform) {
  return useMemo(() => {
    if (!output)
      return [];
    const unwrapQ1 = (output2) => {
      if (output2 && !Array.isArray(output2) && typeof output2 === "object" && Object.keys(output2).length === 1 && Object.keys(output2)[0] === "Q1") {
        return output2["Q1"];
      }
      return output2;
    };
    const unwrappedOutput = unwrapQ1(output);
    if (outputTransform) {
      return outputTransform(unwrappedOutput);
    }
    return unwrappedOutput;
  }, [output, outputTransform]);
}
export {
  ChartWithTask,
  doesUseTask
};
//# sourceMappingURL=ChartWithTask.js.map
