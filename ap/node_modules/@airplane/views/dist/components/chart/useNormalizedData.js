import { useMantineTheme } from "@mantine/core";
const DEFAULT_COLORS = ["blue", "lime", "orange", "teal", "yellow", "cyan", "violet", "red"];
const useNormalizedData = (props, selectionIndexes = /* @__PURE__ */ new Map()) => {
  const theme = useMantineTheme();
  if (!props.data || Array.isArray(props.data) && props.data.length === 0) {
    return [];
  }
  switch (props.type) {
    case "line":
      return seriesData(props, {
        type: "scatter",
        mode: "lines+markers"
      }, selectionIndexes, theme);
    case "scatter":
      return seriesData(props, {
        type: "scatter",
        mode: "markers"
      }, selectionIndexes, theme);
    case "bar":
      return seriesData(props, {
        type: "bar"
      }, selectionIndexes, theme);
    case "pie":
      return pieData(props, theme);
  }
};
const seriesData = (props, plotlyDataOptions, selectionIndexes, theme) => {
  const xAxis = props.xAxis ?? firstField(props.data);
  const dataSets = props.datasets ?? fields(props.data).slice(1);
  const x = pluck(props.data, xAxis);
  const hasSelection = selectionIndexes.size > 0;
  return dataSets.map((dataSet, idx) => {
    var _a;
    const colorProp = (_a = props.colors) == null ? void 0 : _a[dataSet];
    const color = resolveColor(theme, idx, colorProp);
    return {
      type: plotlyDataOptions.type,
      mode: plotlyDataOptions.mode,
      x,
      y: pluck(props.data, dataSet),
      name: dataSet,
      selectedpoints: hasSelection ? selectionIndexes.get(dataSet) ?? [] : void 0,
      marker: {
        color
      }
    };
  });
};
const pieData = (props, theme) => {
  const dataSet = props.dataset ?? firstField(props.data);
  const colors = (props.colors ?? DEFAULT_COLORS).map((color, idx) => resolveColor(theme, idx, color));
  return [{
    type: "pie",
    name: dataSet,
    values: pluck(props.data, dataSet),
    labels: props.labels,
    marker: {
      colors
    }
  }];
};
const pluck = (d, prop) => {
  if (Array.isArray(d)) {
    return d.map((v) => v[prop]);
  } else {
    return d[prop];
  }
};
const firstField = (data) => {
  return fields(data)[0];
};
const fields = (data) => Array.isArray(data) ? Object.keys(data[0]) : Object.keys(data);
const resolveColor = (theme, idx, color) => {
  const colorIndex = 6;
  if (!color) {
    return theme.colors[DEFAULT_COLORS[idx]][colorIndex];
  }
  if (!theme.colors[color]) {
    return color;
  }
  return theme.colors[color][colorIndex];
};
export {
  firstField,
  useNormalizedData
};
//# sourceMappingURL=useNormalizedData.js.map
