{"version":3,"file":"parameters.js","sources":["../../../src/components/form/parameters.tsx"],"sourcesContent":["import { Input } from \"@mantine/core\";\nimport dayjs from \"dayjs\";\nimport json5 from \"json5\";\nimport { isArray } from \"lodash-es\";\nimport { ReactElement, useEffect, useRef, useState } from \"react\";\nimport { useDebouncedCallback } from \"use-debounce\";\n\nimport {\n  ConstraintOption,\n  MultiParamValue,\n  ParamValue,\n  ParamValues,\n  Parameter,\n  Template,\n  isConstraintOptions,\n  isTaskOption,\n  isTemplate,\n} from \"client/types\";\nimport { Checkbox } from \"components/checkbox/Checkbox\";\nimport { CodeInput } from \"components/codeinput/CodeInput\";\nimport { DatePicker } from \"components/datepicker/DatePicker\";\nimport { DateTimePicker } from \"components/datepicker/DateTimePicker\";\nimport { FileInput } from \"components/fileinput/FileInput\";\nimport { MultiInput as MultiInputComponent } from \"components/multiInput/MultiInput\";\nimport { MultiSelect } from \"components/multiselect/MultiSelect\";\nimport { NumberInput } from \"components/number/NumberInput\";\nimport { Select, outputToData } from \"components/select/Select\";\nimport { Textarea } from \"components/textarea/Textarea\";\nimport { TextInput } from \"components/textinput/TextInput\";\nimport { useTaskQuery } from \"state\";\nimport { useRegisterFormInput } from \"state/components/form/useRegisterFormInput\";\nimport { ValidateFnProp } from \"state/components/input/types\";\nimport { useInput } from \"state/components/input/useInput\";\nimport { useMultiInputState } from \"state/components/multiInput\";\nimport { useComponentId } from \"state/components/useId\";\nimport { useSyncComponentState } from \"state/context/context\";\n\nimport {\n  FieldOption,\n  RunbookOptions,\n  TaskOptions,\n  ParamValue as FormInputParamValue,\n} from \"./Form.types\";\nimport { useEvaluateTemplate, useEvaluateTemplates } from \"./jst\";\n\ninterface ParamConfig {\n  getInput: (\n    props: {\n      required: boolean;\n      id: string;\n      label: string;\n      disabled?: boolean;\n\n      // The below props are optional when getInput must be used as a controlled component.\n\n      /** The value of the input if the input is controlled.  */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Rather than use generics, just assume that the value is the correct type.\n      value?: any;\n      /** Called when the input value changes if the input is controlled.  */\n      onChange?: (e: unknown) => void;\n    },\n    component?: string,\n  ) => ReactElement;\n\n  validate: (\n    val: string | boolean | Date | number,\n    slug: string,\n    constraints?: ParamValue[],\n  ) => string | undefined;\n}\n\nconst PARAM_CONFIG_MAP: Record<Parameter[\"type\"], ParamConfig> = {\n  boolean: {\n    getInput: (props) => <Checkbox {...props} checked={props.value} />,\n    validate: (val, slug) => {\n      if (typeof val !== \"boolean\") {\n        return `Value of param ${slug} must be a boolean`;\n      }\n    },\n  },\n  upload: {\n    getInput: (props) => <FileInput {...props} />,\n    validate: () => {\n      return \"Cannot set value constraints for file params\";\n    },\n  },\n  date: {\n    getInput: (props) => <DatePicker {...props} />,\n    validate: (val, slug, constraints) => {\n      if (\n        (typeof val !== \"string\" && !(val instanceof Date)) ||\n        (typeof val === \"string\" && !dayjs(val).isValid()) ||\n        (constraints &&\n          constraints.find(\n            (v) =>\n              typeof v === \"string\" &&\n              new Date(v).getTime() === new Date(val).getTime(),\n          ) === undefined)\n      ) {\n        return `${val} is not a valid value for ${slug}`;\n      }\n    },\n  },\n  datetime: {\n    getInput: (props) => <DateTimePicker {...props} />,\n    validate: (val, slug, constraints) => {\n      if (\n        (typeof val !== \"string\" && !(val instanceof Date)) ||\n        (typeof val === \"string\" && !dayjs(val).isValid()) ||\n        (constraints &&\n          constraints.find(\n            (v) =>\n              typeof v === \"string\" &&\n              new Date(v).getTime() === new Date(val).getTime(),\n          ) === undefined)\n      ) {\n        return `${val} is not a valid value for ${slug}`;\n      }\n    },\n  },\n  float: {\n    getInput: (props) => (\n      <NumberInput precision={9} removeTrailingZeros {...props} />\n    ),\n    validate: (val, slug, constraints) => {\n      if (typeof val !== \"number\") {\n        return `Value of param ${slug} must be a number`;\n      }\n      if (\n        constraints &&\n        constraints.find((v) => Number(v) == val) === undefined\n      ) {\n        return `${val} is not a valid value for ${slug}`;\n      }\n    },\n  },\n  integer: {\n    getInput: (props) => <NumberInput {...props} />,\n    validate: (val, slug, constraints) => {\n      if (typeof val !== \"number\") {\n        return `Value of param ${slug} must be a number`;\n      }\n      if (\n        constraints &&\n        constraints.find((v) => Number(v) == val) === undefined\n      ) {\n        return `${val} is not a valid value for ${slug}`;\n      }\n    },\n  },\n  string: {\n    getInput: (props, component) => {\n      if (component === \"textarea\") {\n        return <Textarea {...props} />;\n      } else if (component === \"editor-sql\") {\n        return <CodeInput {...props} language=\"sql\" />;\n      }\n      return (\n        <TextInput\n          {...props}\n          onChange={(v) => props.onChange?.(v.target.value)}\n        />\n      );\n    },\n    validate: (val, slug, constraints) => {\n      if (typeof val !== \"string\") {\n        return `Value of param ${slug} must be a string`;\n      }\n      if (constraints && !constraints.includes(val)) {\n        return `${val} is not a valid value for ${slug}`;\n      }\n    },\n  },\n  json: {\n    getInput: (props) => {\n      return <CodeInput {...props} language=\"json\" />;\n    },\n    validate: (val, slug) => {\n      if (typeof val !== \"string\") {\n        return `Value of param ${slug} must be a string`;\n      }\n      try {\n        json5.parse(val);\n      } catch {\n        return `Value of param ${slug} must be valid JSON`;\n      }\n    },\n  },\n};\n\ntype ParameterInputProps = {\n  param: Parameter;\n  paramValues: ParamValues;\n  idPrefix: string;\n  /** A callback that is called to change the value of the parameter. */\n  onChange: (value: unknown) => void;\n  /** The current value of the parameter. */\n  value?: unknown;\n  opt?: FieldOption;\n};\n\n/** ParameterInput represents the UI component for a single parameter. */\nexport const ParameterInput = ({\n  param,\n  idPrefix,\n  opt,\n  paramValues,\n  onChange,\n  value,\n}: ParameterInputProps) => {\n  const defaultValue = opt?.defaultValue ?? param.default;\n  const hiddenEval = useEvaluateTemplate(\n    param.hidden,\n    { params: paramValues },\n    { forceEvaluate: true },\n  );\n  const isHidden =\n    param.hidden && (hiddenEval.result || hiddenEval.initialLoading);\n\n  const validateEval = useEvaluateTemplate(\n    param.constraints.validate,\n    { params: paramValues },\n    { forceEvaluate: true },\n  );\n\n  const taskBackedConstraintOptionsLoaded = useRef(false);\n  const {\n    constraintOptions: taskBackedConstraintOptions,\n    error: taskBackedConstraintError,\n    isLoading: taskBackedConstraintLoading,\n  } = useTaskBackedConstraintOptions({\n    param,\n    paramValues: paramValues ?? {},\n    enabled: !isHidden,\n  });\n\n  if (\n    value &&\n    isTaskOption(param.constraints.options) &&\n    taskBackedConstraintOptionsLoaded.current &&\n    !taskBackedConstraintOptions?.some((o) => {\n      if (isArray(value)) {\n        return value.includes(o.value);\n      }\n      return o.value === value;\n    })\n  ) {\n    // If the value is not in the list of task-backed constraint options, then it is invalid.\n    onChange(undefined);\n  }\n  if (\n    taskBackedConstraintOptions &&\n    !taskBackedConstraintOptionsLoaded.current\n  ) {\n    // After the task backed constraints load a single time, reset the default value.\n    if (opt?.value ?? defaultValue) {\n      onChange(canonicalizeValue(opt?.value ?? defaultValue, param.type));\n    }\n    taskBackedConstraintOptionsLoaded.current = true;\n  }\n\n  // Hide the param if the hidden expression evaluates to true, or if we're still loading the\n  // initial value so we don't know yet.\n  if (isHidden) {\n    return null;\n  }\n  if (opt?.value !== undefined) {\n    return (\n      <Input.Label>{`${param.slug}: ${JSON.stringify(opt.value)}`}</Input.Label>\n    );\n  }\n  const props = {\n    required: !param.constraints.optional,\n    id: idPrefix + param.slug,\n    label: param.name,\n    ...(param.type === \"boolean\"\n      ? { defaultChecked: defaultValue == null ? undefined : !!defaultValue }\n      : { defaultValue: defaultValue == null ? undefined : defaultValue }),\n    validate: (e: unknown): string | undefined => {\n      const optValidationResult = opt?.validate?.(e);\n      if (optValidationResult) {\n        return optValidationResult;\n      }\n      if (param.constraints.regex) {\n        const regex = new RegExp(param.constraints.regex);\n\n        // If the value is an array (multi param), we need to test each value.\n        let valsToTest = [e];\n        if (Array.isArray(e)) {\n          valsToTest = e;\n        }\n        for (const val of valsToTest) {\n          if (typeof val === \"string\" && !regex.test(val)) {\n            return `${param.name} does not match the following pattern: ${param.constraints.regex}`;\n          }\n        }\n      }\n      if (validateEval.result) {\n        return typeof validateEval.result === \"string\"\n          ? validateEval.result\n          : JSON.stringify(validateEval.result);\n      }\n      if (hiddenEval.error) {\n        return `Error evaluating hidden expression for ${param.name}: ${hiddenEval.error}`;\n      }\n      if (validateEval.error) {\n        return `Error evaluating validation expression for ${param.name}: ${validateEval.error}`;\n      }\n      return undefined;\n    },\n    // This is not param?.desc because we don't want to pass an empty string desc\n    description: param.desc || undefined,\n    disabled: opt?.disabled,\n  };\n\n  let constraintOptions: ConstraintOption[] | undefined = undefined;\n  if (param.constraints?.options) {\n    if (isConstraintOptions(param.constraints.options)) {\n      constraintOptions = param.constraints.options;\n    } else if (taskBackedConstraintOptions) {\n      constraintOptions = taskBackedConstraintOptions;\n    }\n  }\n\n  let options:\n    | Array<string | number | { value: string | number; label: string }>\n    | undefined = undefined;\n  if (opt?.allowedValues) {\n    options = canonicalizeValues(opt.allowedValues, param.type);\n    if (constraintOptions) {\n      options = filterValues(\n        options as string[],\n        constraintOptions,\n        param.type,\n      );\n    }\n  } else if (constraintOptions) {\n    options = constraintOptions.map((v) => ({\n      label: v.label || String(v.value), // Override not set or empty (\"\") label\n      value: typeof v.value === \"number\" ? v.value : String(v.value),\n    }));\n  }\n\n  if (options || isTaskOption(param.constraints.options)) {\n    if (param.multi) {\n      // If the task has options and is multi, render a multi select.\n      return (\n        <MultiSelect\n          clearable\n          {...props}\n          defaultValue={canonicalizeValues(\n            (defaultValue as MultiParamValue) ?? [],\n            param.type,\n          )}\n          data={options ?? []}\n          loading={taskBackedConstraintLoading}\n          error={taskBackedConstraintError}\n        />\n      );\n    }\n    return (\n      <Select\n        clearable\n        {...props}\n        defaultValue={canonicalizeValue(defaultValue, param.type)}\n        data={options ?? []}\n        loading={taskBackedConstraintLoading}\n        error={taskBackedConstraintError}\n      />\n    );\n  }\n  if (param.multi) {\n    // If the task does not have options and is multi, render a multi input\n    // with the correct input component.\n\n    const persistDefaultValueType =\n      param.type === \"integer\" || param.type === \"boolean\";\n    return (\n      <MultiInput\n        id={props.id}\n        label={props.label}\n        description={props.description}\n        disabled={props.disabled}\n        paramType={param.type}\n        paramComponent={param.component}\n        required={props.required}\n        defaultValue={\n          persistDefaultValueType\n            ? (defaultValue as MultiParamValue) ?? []\n            : canonicalizeValues(\n                (defaultValue as MultiParamValue) ?? [],\n                param.type,\n              )\n        }\n        validate={props.validate}\n      />\n    );\n  }\n  return PARAM_CONFIG_MAP[param.type]?.getInput(props, param.component);\n};\n\n/**\n * MultiInput is an uncontrolled wrapper around the MultiInput component. It tracks the values in the component,\n * syncs the values to the component state, registers it on the form, and renders the proper input component.\n */\nconst MultiInput = ({\n  id: propsId,\n  label,\n  description,\n  paramType,\n  paramComponent,\n  disabled,\n  required,\n  defaultValue = [],\n  validate,\n}: {\n  id: string;\n  label: string;\n  description?: string;\n  paramType: Parameter[\"type\"];\n  paramComponent: Parameter[\"component\"];\n  disabled?: boolean;\n  required?: boolean;\n  defaultValue: unknown[];\n  validate?: ValidateFnProp<unknown>;\n}) => {\n  const id = useComponentId(propsId);\n  const { state, dispatch } = useMultiInputState(id, {\n    initialState: {\n      disabled,\n      value: defaultValue,\n    },\n  });\n  const { inputProps } = useInput(\n    { required, validate },\n    state,\n    dispatch,\n    () => [],\n  );\n  useSyncComponentState(id, state);\n  useRegisterFormInput(id, \"multi-input\");\n  const values = state.value ?? [];\n\n  return (\n    <MultiInputComponent\n      id={id}\n      label={label}\n      description={description}\n      onAdd={() =>\n        dispatch({\n          type: \"setValue\",\n          value: [...(state.value ?? []), undefined],\n        })\n      }\n      onRemove={(i) => {\n        dispatch({\n          type: \"setValue\",\n          value: [\n            ...(state.value ?? []).slice(0, i),\n            ...(state.value ?? []).slice(i + 1),\n          ],\n        });\n      }}\n      values={values}\n      addDisabled={values.length > 0 && values[values.length - 1] == undefined}\n      required={required}\n      renderInput={({ index, value }) =>\n        PARAM_CONFIG_MAP[paramType]?.getInput(\n          {\n            required: false,\n            id: `${id}-${index}`,\n            label: \"\",\n            value,\n            disabled,\n            onChange: (v: unknown) => {\n              const currentValues = state.value ?? [];\n              dispatch({\n                type: \"setValue\",\n                value: [\n                  ...currentValues.slice(0, index),\n                  v,\n                  ...currentValues.slice(index + 1),\n                ],\n              });\n            },\n          },\n          paramComponent,\n        )\n      }\n      {...inputProps}\n    />\n  );\n};\n\nexport const validateParameterOptions = <TOutput,>(\n  params: Parameter[],\n  opts: TaskOptions<TOutput> | RunbookOptions,\n) => {\n  for (const param of params) {\n    // Check that all required fields are set or not hidden\n    if (\n      !param.constraints.optional &&\n      ((opts.shownFields && !opts.shownFields.includes(param.slug)) ||\n        opts.hiddenFields?.includes(param.slug)) &&\n      (!opts.fieldOptions ||\n        opts.fieldOptions.find((o) => o.slug === param.slug)?.value ===\n          undefined)\n    ) {\n      return \"All required fields that are hidden must have a value specified\";\n    }\n  }\n  if (opts.fieldOptions) {\n    for (const opt of opts.fieldOptions) {\n      // Check no extraneous slugs\n      const param = params.find((p) => p.slug === opt.slug);\n      if (!param) {\n        return `Found extraneous param in fieldOptions: ${opt.slug}`;\n      }\n      // Check that allowedValues has length at least 2\n      if (opt.allowedValues && opt.allowedValues.length < 2) {\n        return `allowedValues for param ${opt.slug} must have length at least 2`;\n      }\n\n      const constraints = isConstraintOptions(param.constraints.options)\n        ? param.constraints.options.map((v) => v.value)\n        : undefined;\n      // Check that all values are valid\n      let valuesToCheck: FormInputParamValue[] = opt.allowedValues || [];\n      if (opt.defaultValue !== undefined) {\n        if (param.multi && !Array.isArray(opt.defaultValue)) {\n          return `defaultValue for multi param ${opt.slug} must be an array`;\n        } else if (!param.multi && Array.isArray(opt.defaultValue)) {\n          return `defaultValue for ${opt.slug} cannot be an array`;\n        }\n        const dv = Array.isArray(opt.defaultValue)\n          ? opt.defaultValue\n          : [opt.defaultValue];\n        valuesToCheck = [...valuesToCheck, ...dv.flat()];\n      }\n      if (opt.value !== undefined) {\n        if (param.multi && !Array.isArray(opt.value)) {\n          return `value for multi param ${opt.slug} must be an array`;\n        } else if (!param.multi && Array.isArray(opt.value)) {\n          return `value for param ${opt.slug} cannot be an array`;\n        }\n        const v = Array.isArray(opt.value) ? opt.value : [opt.value];\n        valuesToCheck = [...valuesToCheck, ...v.flat()];\n      }\n      for (const val of valuesToCheck) {\n        const validateResult = PARAM_CONFIG_MAP[param.type]?.validate(\n          val,\n          opt.slug,\n          constraints,\n        );\n        if (validateResult) {\n          return validateResult;\n        }\n      }\n    }\n  }\n};\n\n/**\n * Converts `value` to a string.\n */\nconst canonicalizeValue = (\n  value: Date | ParamValue,\n  type: string,\n): string | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return String(value);\n  }\n  if (typeof value === \"string\") {\n    if (type === \"date\") {\n      // For dates, string values are allowed. We canonicalize string values by\n      // getting the ISO format string. We need to check if date.getTime() has a\n      // valid value, because this function runs before validation, and toISOString\n      // will crash the view if the date is invalid. We take the first 10 characters\n      // because the backend expects a date format that looks like \"2006-01-02\".\n      const date = dayjs(value);\n      return date.isValid() ? date.format(\"YYYY-MM-DD\") : \"\";\n    } else if (type === \"datetime\") {\n      const date = dayjs(value);\n      return date.isValid() ? date.toISOString() : \"\";\n    } else {\n      return value;\n    }\n  }\n  return JSON.stringify(value);\n};\n\n/**\n * Converts `values` to a string array.\n */\nconst canonicalizeValues = (\n  values: Date[] | MultiParamValue,\n  type: string,\n): string[] => {\n  return values\n    .map((v) => canonicalizeValue(v, type))\n    .filter((v) => v !== undefined) as string[];\n};\n\n/**\n * Returns the subset of `values` that matches a constraint in `constraints`.\n */\nconst filterValues = (\n  values: string[],\n  constraints: ConstraintOption[],\n  type: string,\n): string[] => {\n  if (type === \"date\" || type === \"datetime\") {\n    const constraintValues = constraints.map((v) =>\n      new Date(String(v.value)).getTime(),\n    );\n    return values.filter((v) =>\n      constraintValues.includes(new Date(v).getTime()),\n    );\n  } else {\n    const constraintValues = constraints.map((v) => v.value);\n    return values.filter((v) => constraintValues.includes(v));\n  }\n};\n\n/**\n * useTaskBackedConstraintOptions evaluates and executes the task specified in the constraint options and\n * returns the output as constraint options.\n */\nconst useTaskBackedConstraintOptions = ({\n  param,\n  paramValues: inputParamValues,\n  enabled: inputEnabled = true,\n}: {\n  param: Parameter;\n  paramValues: ParamValues;\n  enabled?: boolean;\n}) => {\n  const [paramValues, setParamValues] = useState(inputParamValues);\n  const [enabled, setEnabled] = useState(inputEnabled);\n  const debounced = useDebouncedCallback<(pv: typeof inputParamValues) => void>(\n    (pv) => {\n      setParamValues(pv);\n    },\n    500,\n  );\n  useEffect(() => {\n    // Debounce paramValues so we don't execute the task every time something changes.\n    debounced(inputParamValues);\n  }, [debounced, inputParamValues]);\n\n  useEffect(() => {\n    // If the enabled state changes, immediately set the paramValues to the inputParamValues.\n    setParamValues(inputParamValues);\n    setEnabled(inputEnabled);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inputEnabled]);\n\n  const taskBackedOptions = isTaskOption(param.constraints.options)\n    ? param.constraints.options\n    : undefined;\n\n  // Evaluate any templates that exist in the task params.\n  const canContainTemplate = (v: ParamValue): v is Template | string =>\n    isTemplate(v) || typeof v === \"string\";\n  const taskBackedParams = Object.entries(taskBackedOptions?.params ?? {});\n  const taskBackedParamTemplates = taskBackedParams.map((p) => {\n    return canContainTemplate(p[1]) ? p[1] : \"\";\n  });\n  const { results, errors, initialLoading } = useEvaluateTemplates(\n    enabled ? taskBackedParamTemplates : undefined,\n    {\n      params: paramValues,\n    },\n  );\n  const evaluatedTaskBackedParamMap: [string, ParamValue][] =\n    taskBackedParams.map((p, i) => {\n      if (canContainTemplate(p[1])) {\n        return [p[0], results[i] as ParamValue];\n      }\n      return p;\n    });\n  const evaluatedTaskBackedParams = Object.fromEntries(\n    evaluatedTaskBackedParamMap,\n  );\n\n  // Execute the task once param evaluation is complete.\n  const {\n    output: taskBackedOutput,\n    error: executeError,\n    loading: isExecuting,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } = useTaskQuery<any>({\n    slug: taskBackedOptions?.slug ?? \"\",\n    params: evaluatedTaskBackedParams,\n    enabled: enabled && !initialLoading && !!taskBackedOptions?.slug,\n  });\n  // Convert the task output to constraint options.\n  const data = taskBackedOutput ? outputToData(taskBackedOutput) : null;\n  const constraintOptions = data?.map((d) => ({\n    value: typeof d === \"object\" ? d.value : d,\n    label: typeof d === \"object\" ? d.label || String(d.value) : String(d),\n  }));\n\n  return {\n    constraintOptions,\n    error: [...errors, executeError?.message].filter((e) => !!e).join(\"\\n\"),\n    isLoading: initialLoading || isExecuting,\n  };\n};\n"],"names":["PARAM_CONFIG_MAP","boolean","getInput","props","value","validate","val","slug","upload","date","constraints","Date","dayjs","isValid","find","v","getTime","undefined","datetime","float","Number","integer","string","component","onChange","target","includes","json","json5","parse","ParameterInput","param","idPrefix","opt","paramValues","defaultValue","default","hiddenEval","useEvaluateTemplate","hidden","params","forceEvaluate","isHidden","result","initialLoading","validateEval","taskBackedConstraintOptionsLoaded","useRef","constraintOptions","taskBackedConstraintOptions","error","taskBackedConstraintError","isLoading","taskBackedConstraintLoading","useTaskBackedConstraintOptions","enabled","isTaskOption","options","current","some","o","isArray","canonicalizeValue","type","JSON","stringify","required","optional","id","label","name","defaultChecked","e","optValidationResult","regex","RegExp","valsToTest","Array","test","description","desc","disabled","isConstraintOptions","allowedValues","canonicalizeValues","filterValues","map","String","multi","persistDefaultValueType","MultiInput","propsId","paramType","paramComponent","useComponentId","state","dispatch","useMultiInputState","initialState","inputProps","useInput","useSyncComponentState","useRegisterFormInput","values","MultiInputComponent","i","slice","length","index","currentValues","validateParameterOptions","opts","shownFields","hiddenFields","fieldOptions","p","valuesToCheck","dv","flat","validateResult","toISOString","format","filter","constraintValues","inputParamValues","inputEnabled","setParamValues","useState","setEnabled","debounced","useDebouncedCallback","pv","useEffect","taskBackedOptions","canContainTemplate","isTemplate","taskBackedParams","Object","entries","taskBackedParamTemplates","results","errors","useEvaluateTemplates","evaluatedTaskBackedParamMap","evaluatedTaskBackedParams","fromEntries","output","taskBackedOutput","executeError","loading","isExecuting","useTaskQuery","data","outputToData","d","message","join"],"mappings":"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"}