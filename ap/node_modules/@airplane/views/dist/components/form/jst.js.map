{"version":3,"file":"jst.js","sources":["../../../src/components/form/jst.ts"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\n\nimport { EVALUATE_TEMPLATE } from \"client/endpoints\";\nimport { Fetcher } from \"client/fetcher\";\n\n/**\n * Parses a template string into template and non-template fragments. For example, the string\n * `Hello {{ \"world!\"}}!` would be split into [\"Hello \", `{{ \"world!\" }}`, \"!\"].\n *\n * A fragment in the returned response is a template if it starts with \"{{\".\n *\n * This logic is a direct port of `expressions.NewTemplate` from airport. Any changes here\n * should be ported to airport and vice-versa.\n */\nconst newTemplate = (s: string): string[] => {\n  if (s.length === 0) {\n    return [];\n  }\n\n  const fragments: string[] = [];\n  let next = \"\"; // the next fragment to capture\n  // const ci = 0; // capture index: we're capturing characters from [0, ci)\n  for (let i = 0; i < s.length; i++) {\n    const c = s[i]; // current character\n\n    const isLast = i + 1 == s.length;\n    if (isLast) {\n      next += c;\n      continue;\n    }\n\n    const nc = s[i + 1]; // next character\n\n    if (c == \"{\") {\n      // If this is not a `{{`, treat it as a raw text.\n      if (nc != \"{\") {\n        next += c;\n        continue;\n      }\n\n      // Otherwise, we found a `{{`. Start processing a template expression.\n      // First off, go ahead and capture everything before the `{{` as a fragment.\n      if (next.length > 0) {\n        fragments.push(next);\n        next = \"\";\n      }\n\n      // Next, get the length of the template expression and extract it as a fragment.\n      const n = measureTemplateExpression(s.substring(i));\n\n      fragments.push(s.substring(i, i + n + 1));\n      i += n;\n    } else if (c == \"\\\\\") {\n      // The backslash is used to escape special runes. To check for this, we inspect the next rune.\n      if (nc === \"{\" || nc === \"}\" || nc === \"\\\\\") {\n        // \"Escape\" the next char so it is treated as raw text by capturing `nc`.\n        next += nc; // capture `nc` and ignore `c`\n        i++; // skip `nc`\n      } else {\n        // This is not a valid escape sequence, so we treat the `\\` as raw text.\n        next += c;\n      }\n    } else {\n      // This is not a special char, so just capture it like normal.\n      // Note this includes the `}` char which we only look for after finding a `{{`.\n      next += c;\n    }\n  }\n\n  // Capture any remaining text as a final raw fragment.\n  if (next.length > 0) {\n    fragments.push(next);\n  }\n\n  return fragments;\n};\n\n// measureTemplateExpression returns the length of a template expression within `s`. The first\n// two chars in `s` must both be opening curly brackets. If there are no valid closing double\n// curlys in `s`, an error will be thrown. Otherwise, the length of the template expression\n// (which includes both the opening and closing double curlys) will be returned.\nconst measureTemplateExpression = (s: string): number => {\n  // We'll traverse forward until we reach the `}}` that end this template expression.\n  // However, the contents of this template expression could contain unrelated curlys.\n  // To handle this, maintain the current depth of curlys so we can ignore them.\n  let depth = 0;\n  // In certain cases, we ignore curlys. Specifically, if a curly is inside of a JS string\n  // then we ignore it. We may expand this in the future.\n  let qm: \"none\" | \"double\" | \"single\" | \"backtick\" = \"none\"; // quote mode\n  let pc = \"\"; // previous char\n  // If a template expression contains invalid JS, we'll \"close\" the template expression\n  // with the last `}}` we find, if any.\n  let lastdci = -1; // last double curly index\n\n  for (let i = 0; i < s.length; i++) {\n    const c = s[i]; // current character\n\n    if (c === \"\\\\\") {\n      // Check if we are escaping a quote.\n      if (i + 1 < s.length) {\n        const nc = s[i + 1]; // next character\n        if (nc === '\"' || nc === \"'\" || nc === \"`\") {\n          // This is an escaped quote. Skip it in the next pass so it won't update `qm`.\n          i++;\n        }\n      }\n    } else if (c === '\"') {\n      // Toggle the double-quote mode.\n      if (qm === \"none\") {\n        qm = \"double\";\n      } else if (qm === \"double\") {\n        qm = \"none\";\n      }\n    } else if (c === \"'\") {\n      // Toggle the single-quote mode.\n      if (qm === \"none\") {\n        qm = \"single\";\n      } else if (qm === \"single\") {\n        qm = \"none\";\n      }\n    } else if (c === \"`\") {\n      // Toggle the backtick-quote mode.\n      if (qm === \"none\") {\n        qm = \"backtick\";\n      } else if (qm === \"backtick\") {\n        qm = \"none\";\n      }\n    } else if (c === \"{\") {\n      // Ignore curlys inside of strings.\n      if (qm === \"none\") {\n        depth++;\n      }\n    } else if (c === \"}\") {\n      // Ignore curlys inside of strings.\n      if (qm === \"none\") {\n        depth--;\n      }\n\n      if (pc === \"}\") {\n        // We've found the double closing curlys.\n        lastdci = i;\n        if (depth === 0) {\n          // These curlys match with the original curlys.\n          return i;\n        }\n      }\n    }\n\n    pc = c;\n  }\n\n  // We were not able to find a closing double curly.\n  // If we found as least one double curly, treat that as the end of the template expression.\n  if (lastdci > -1) {\n    return lastdci;\n  }\n\n  // Otherwise, return an error.\n  throw new Error(\"Invalid template\");\n};\n\nconst unpackTemplate = (v: Template | string): string =>\n  isTemplate(v) ? v.raw : v;\n\ntype EvaluateTemplateOptions = {\n  /** If true, the template is always treated as a template even if it isn't wraped in {{}} */\n  forceEvaluate?: boolean;\n};\n/**\n * Hook that evaluates a template with the given args.\n *\n * Returns the result and error of the evaluation.\n *\n * Also returns an initial loading flag that is true until the first result is returned\n * and a loading flag that is true while any evaluation is in progress.\n */\nexport const useEvaluateTemplate = (\n  template?: Template | string,\n  args?: Record<string, unknown>,\n  opts: EvaluateTemplateOptions = {},\n) => {\n  const { results, errors, loading, initialLoading } = useEvaluateTemplates(\n    [template],\n    args,\n    opts,\n  );\n  return { result: results[0], error: errors[0], loading, initialLoading };\n};\n\ntype TemplateEvalResult = { result?: unknown; error?: string };\n/**\n * Hook that evaluates multiple templates with the given args.\n *\n * Returns the results and errors of the evaluation as an array that corresponds to the input templates.\n *\n * Also returns an initial loading flag that is true until all templates have been evaluated once\n * and a loading flag that is true while any evaluation is in progress.\n */\nexport const useEvaluateTemplates = (\n  templates?: Array<string | Template | undefined>,\n  args?: Record<string, unknown>,\n  opts: EvaluateTemplateOptions = {},\n) => {\n  const [results, setResults] = useState<(TemplateEvalResult | undefined)[]>(\n    [],\n  );\n  const cacheRef = useRef<Record<string, TemplateEvalResult>>({});\n  const numLoadingRef = useRef(0);\n\n  const addResult = (result: TemplateEvalResult | undefined, i: number) => {\n    setResults((r) => (r ? [...r.slice(0, i), result, ...r.slice(i + 1)] : r));\n  };\n\n  const templatesStr = JSON.stringify(templates);\n  const argsStr = JSON.stringify(args);\n  useEffect(() => {\n    const evaluateServer = async (\n      t: Template | string,\n      i: number,\n      cacheKey: string,\n    ) => {\n      let response: { value: Record<string, unknown> } | undefined = undefined;\n      let errString = \"\";\n      let raw = unpackTemplate(t);\n      if (opts.forceEvaluate && !raw.startsWith(\"{{\")) {\n        raw = `{{${raw}}}`;\n      }\n      try {\n        const fetcher = new Fetcher();\n        response = await fetcher.post<{ value: Record<string, unknown> }>(\n          EVALUATE_TEMPLATE,\n          {\n            value: raw,\n            lookupMaps: args,\n            disableDefaultLookupMaps: true,\n          },\n        );\n      } catch (e: unknown) {\n        if (e instanceof Error) {\n          errString = e.message;\n        } else {\n          errString = \"Unknown error\";\n        }\n      }\n      cacheRef.current[cacheKey] = {\n        result: response?.value,\n        error: errString,\n      };\n      numLoadingRef.current--;\n      addResult({ result: response?.value, error: errString }, i);\n    };\n    templates?.forEach((t, i) => {\n      const cacheKey = JSON.stringify({ t, args });\n      if (!t) {\n        addResult(undefined, i);\n      } else if (cacheRef.current[cacheKey]) {\n        addResult(cacheRef.current[cacheKey], i);\n      } else if (\n        !opts.forceEvaluate &&\n        !newTemplate(unpackTemplate(t)).some((f) => f.startsWith(\"{{\"))\n      ) {\n        // There is no template expression in this string, so we can just return it as-is.\n        addResult({ result: unpackTemplate(t) }, i);\n      } else {\n        numLoadingRef.current++;\n        evaluateServer(t, i, cacheKey);\n      }\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [argsStr, templatesStr, opts.forceEvaluate]);\n\n  const initialLoading =\n    templates?.length && results.length !== templates.length;\n\n  return {\n    results: results.map((r) => r?.result),\n    errors: results.map((r) => r?.error ?? \"\"),\n    initialLoading,\n    loading: initialLoading || numLoadingRef.current > 0,\n  };\n};\n\ntype Template = {\n  __airplaneType: \"template\";\n  raw: string;\n};\n\nconst isTemplate = (v: unknown): v is Template =>\n  v != null &&\n  typeof v === \"object\" &&\n  (v as Template)[\"__airplaneType\"] === \"template\";\n"],"names":["newTemplate","s","length","fragments","next","i","c","isLast","nc","push","n","measureTemplateExpression","substring","depth","qm","pc","lastdci","Error","unpackTemplate","v","isTemplate","raw","useEvaluateTemplate","template","args","opts","results","errors","loading","initialLoading","useEvaluateTemplates","result","error","templates","setResults","useState","cacheRef","useRef","numLoadingRef","addResult","r","slice","templatesStr","JSON","stringify","argsStr","useEffect","evaluateServer","t","cacheKey","response","undefined","errString","forceEvaluate","startsWith","fetcher","Fetcher","post","EVALUATE_TEMPLATE","value","lookupMaps","disableDefaultLookupMaps","e","message","current","forEach","some","f","map"],"mappings":"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"}