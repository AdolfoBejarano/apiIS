{"version":3,"file":"TableWithTask.js","sources":["../../../src/components/table/TableWithTask.tsx"],"sourcesContent":["import { useMemo } from \"react\";\n\nimport { DefaultOutput, DefaultParams, ParamValues } from \"client\";\nimport {\n  SetLatestRunProps,\n  useSetLatestRunInTaskQuery,\n} from \"components/errorBoundary/LatestRunDetails\";\nimport { getFullMutation } from \"components/query\";\nimport { displayTaskBackedError } from \"errors/displayTaskBackedError\";\nimport { useTaskQuery } from \"state\";\n\nimport { ConnectedTable } from \"./ConnectedTable\";\nimport {\n  TableComponentProps,\n  TableProps,\n  TableWithTaskProps,\n} from \"./Table.types\";\n\n/**\n * TableWithTask is a connected table that can directly populate its data from a task.\n */\nexport const TableWithTask = <\n  TRowData extends object,\n  TParams extends ParamValues | undefined = DefaultParams,\n  TOutput = DefaultOutput,\n>({\n  outputTransform,\n  task,\n  rowActions,\n  rowActionsMenu,\n  setLatestRun,\n  ...tableProps\n}: TableWithTaskProps<TRowData, TParams, TOutput> & SetLatestRunProps) => {\n  const fullQuery = useSetLatestRunInTaskQuery<TParams>(task, setLatestRun);\n  const { error, loading, output, runID } = useTaskQuery<TParams, TOutput>(\n    fullQuery,\n  );\n  const data = useOutputToData(output, outputTransform);\n\n  let arrayRowActions = rowActions\n    ? Array.isArray(rowActions)\n      ? rowActions\n      : [rowActions]\n    : [];\n  // Update the refetchTasks of each TaskRowAction (if not explicitly set)\n  // to refetch the table task.\n  arrayRowActions = arrayRowActions.map((rowAction) => {\n    // If the row action is ComponentRowAction or BasicRowAction, ignore.\n    if (typeof rowAction === \"function\") {\n      return rowAction;\n    }\n    if (\n      typeof rowAction !== \"string\" &&\n      !(\"slug\" in rowAction) &&\n      !(\"fn\" in rowAction)\n    ) {\n      return rowAction;\n    }\n\n    const fullMutation = getFullMutation(rowAction);\n    if (!fullMutation.refetchTasks) {\n      fullMutation.refetchTasks = task;\n    }\n    return fullMutation;\n  });\n\n  let arrayRowMenuActions = rowActionsMenu\n    ? Array.isArray(rowActionsMenu)\n      ? rowActionsMenu\n      : [rowActionsMenu]\n    : [];\n  arrayRowMenuActions = arrayRowMenuActions.map((rowAction) => {\n    if (\n      typeof rowAction !== \"string\" &&\n      !(\"slug\" in rowAction) &&\n      !(\"fn\" in rowAction)\n    ) {\n      return rowAction;\n    }\n\n    const fullMutation = getFullMutation(rowAction);\n    if (!fullMutation.refetchTasks) {\n      fullMutation.refetchTasks = task;\n    }\n    return fullMutation;\n  });\n\n  if (error) {\n    return displayTaskBackedError({\n      error,\n      taskSlug: fullQuery.slug,\n      runID,\n      componentName: \"Table\",\n    });\n  } else {\n    return (\n      <ConnectedTable\n        {...tableProps}\n        data={data}\n        loading={loading}\n        // key is necessary for React to recognize this as a separate Table\n        // instance. This allows initialization to happen again when the data\n        // is ready, allowing for accurate initialState values.\n        key={\n          loading && !!tableProps.isDefaultSelectedRow ? \"loading\" : undefined\n        }\n        rowActions={arrayRowActions}\n        rowActionsMenu={arrayRowMenuActions}\n      />\n    );\n  }\n};\n\nfunction useOutputToData<\n  TRowData extends object,\n  TParams extends ParamValues,\n  TOutput,\n>(\n  output?: TOutput,\n  outputTransform?: TableWithTaskProps<\n    TRowData,\n    TParams,\n    TOutput\n  >[\"outputTransform\"],\n): TableComponentProps<TRowData>[\"data\"] {\n  return useMemo(() => {\n    if (!output) return [];\n    // We try unwrapping only if the output is of the form\n    // { Q1: [...] }, as a convenience method for dealing with SQL builtins.\n    const unwrapQ1 = (output: TOutput) => {\n      if (\n        output &&\n        !Array.isArray(output) &&\n        typeof output === \"object\" &&\n        Object.keys(output).length === 1 &&\n        Object.keys(output)[0] === \"Q1\" &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Array.isArray((output as Record<string, any>)[\"Q1\"])\n      ) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (output as Record<string, any>)[\"Q1\"];\n      }\n      return output;\n    };\n\n    const unwrappedOutput = unwrapQ1(output);\n    const transformedOutput = outputTransform\n      ? outputTransform(unwrappedOutput)\n      : unwrappedOutput;\n\n    if (Array.isArray(transformedOutput)) {\n      return transformedOutput;\n    }\n    return [];\n  }, [output, outputTransform]);\n}\n\nexport function doesUseTask<\n  TRowData extends object,\n  TParams extends ParamValues | undefined,\n  TOutput,\n>(\n  props: TableProps<TRowData, TParams, TOutput>,\n): props is TableWithTaskProps<TRowData, TParams, TOutput> {\n  return Boolean(\n    (props as TableWithTaskProps<TRowData, TParams, TOutput>).task,\n  );\n}\n"],"names":["TableWithTask","outputTransform","task","rowActions","rowActionsMenu","setLatestRun","tableProps","fullQuery","useSetLatestRunInTaskQuery","error","loading","output","runID","useTaskQuery","data","useOutputToData","arrayRowActions","Array","isArray","map","rowAction","fullMutation","getFullMutation","refetchTasks","arrayRowMenuActions","displayTaskBackedError","taskSlug","slug","componentName","isDefaultSelectedRow","undefined","useMemo","unwrapQ1","Object","keys","length","unwrappedOutput","transformedOutput","doesUseTask","props","Boolean"],"mappings":";;;;;;AAqBO,MAAMA,gBAAgB,CAI3B;AAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACA,GAAGC;AAC+D,MAAM;AAClEC,QAAAA,YAAYC,2BAAoCN,MAAMG,YAAY;AAClE,QAAA;AAAA,IAAEI;AAAAA,IAAOC;AAAAA,IAASC;AAAAA,IAAQC;AAAAA,EAAAA,IAAUC,aACxCN,SACF;AACMO,QAAAA,OAAOC,gBAAgBJ,QAAQV,eAAe;AAEhDe,MAAAA,kBAAkBb,aAClBc,MAAMC,QAAQf,UAAU,IACtBA,aACA,CAACA,UAAU,IACb;AAGca,oBAAAA,gBAAgBG,IAAKC,CAAc,cAAA;AAE/C,QAAA,OAAOA,cAAc,YAAY;AAC5BA,aAAAA;AAAAA,IACT;AAEE,QAAA,OAAOA,cAAc,YACrB,EAAE,UAAUA,cACZ,EAAE,QAAQA,YACV;AACOA,aAAAA;AAAAA,IACT;AAEMC,UAAAA,eAAeC,gBAAgBF,SAAS;AAC1C,QAAA,CAACC,aAAaE,cAAc;AAC9BF,mBAAaE,eAAerB;AAAAA,IAC9B;AACOmB,WAAAA;AAAAA,EAAAA,CACR;AAEGG,MAAAA,sBAAsBpB,iBACtBa,MAAMC,QAAQd,cAAc,IAC1BA,iBACA,CAACA,cAAc,IACjB;AACkBoB,wBAAAA,oBAAoBL,IAAKC,CAAc,cAAA;AAEzD,QAAA,OAAOA,cAAc,YACrB,EAAE,UAAUA,cACZ,EAAE,QAAQA,YACV;AACOA,aAAAA;AAAAA,IACT;AAEMC,UAAAA,eAAeC,gBAAgBF,SAAS;AAC1C,QAAA,CAACC,aAAaE,cAAc;AAC9BF,mBAAaE,eAAerB;AAAAA,IAC9B;AACOmB,WAAAA;AAAAA,EAAAA,CACR;AAED,MAAIZ,OAAO;AACT,WAAOgB,uBAAuB;AAAA,MAC5BhB;AAAAA,MACAiB,UAAUnB,UAAUoB;AAAAA,MACpBf;AAAAA,MACAgB,eAAe;AAAA,IAAA,CAChB;AAAA,EAAA,OACI;AAEH,WAAA;AAAA,MAAC;AAAA,MAAA;AAAA,QACKtB,GAAAA;AAAAA,QACJ;AAAA,QACA;AAAA,QAIA,KACEI,WAAW,CAAC,CAACJ,WAAWuB,uBAAuB,YAAYC;AAAAA,QAE7D,YAAYd;AAAAA,QACZ,gBAAgBQ;AAAAA,MAAAA;AAAAA,IAAAA;AAAAA,EAGtB;AACF;AAEA,SAAST,gBAKPJ,QACAV,iBAKuC;AACvC,SAAO8B,QAAQ,MAAM;AACnB,QAAI,CAACpB;AAAQ,aAAO;AAGdqB,UAAAA,WAAWA,CAACrB,YAAoB;AAElCA,UAAAA,WACA,CAACM,MAAMC,QAAQP,OAAM,KACrB,OAAOA,YAAW,YAClBsB,OAAOC,KAAKvB,OAAM,EAAEwB,WAAW,KAC/BF,OAAOC,KAAKvB,OAAM,EAAE,CAAC,MAAM;AAAA,MAE3BM,MAAMC,QAASP,QAA+B,IAAI,CAAC,GACnD;AAEA,eAAQA,QAA+B,IAAI;AAAA,MAC7C;AACOA,aAAAA;AAAAA,IAAAA;AAGHyB,UAAAA,kBAAkBJ,SAASrB,MAAM;AACvC,UAAM0B,oBAAoBpC,kBACtBA,gBAAgBmC,eAAe,IAC/BA;AAEAnB,QAAAA,MAAMC,QAAQmB,iBAAiB,GAAG;AAC7BA,aAAAA;AAAAA,IACT;AACA,WAAO;EAAE,GACR,CAAC1B,QAAQV,eAAe,CAAC;AAC9B;AAEO,SAASqC,YAKdC,OACyD;AAClDC,SAAAA,QACJD,MAAyDrC,IAC5D;AACF;"}