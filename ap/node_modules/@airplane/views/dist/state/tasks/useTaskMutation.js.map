{"version":3,"file":"useTaskMutation.js","sources":["../../../src/state/tasks/useTaskMutation.ts"],"sourcesContent":["import { DefaultOutput, ParamValues, DefaultParams } from \"client/executeTask\";\nimport {\n  ExecuteError,\n  TaskMutation,\n  getFullMutation,\n  RefetchQuery,\n} from \"components/query\";\n\nimport { useTaskOrRunbookMutation } from \"./useTaskOrRunbookMutation\";\n\nexport type MutationHookOptions<\n  TParams extends ParamValues | undefined = DefaultParams,\n  TOutput = DefaultOutput,\n> = {\n  /**\n   * The params of the task to execute.\n   */\n  params?: TParams;\n  /**\n   * If set, the provided tasks will be refetched on success.\n   *\n   * This can be useful if you expect the task mutation to invalidate data.\n   */\n  refetchTasks?: RefetchQuery | RefetchQuery[];\n  /**\n   * Callback on successful task execution.\n   */\n  onSuccess?: (output: TOutput, runID: string) => void;\n  /**\n   * Callback on failed task execution.\n   */\n  onError?: (\n    output: TOutput | undefined,\n    error: ExecuteError,\n    runID?: string,\n  ) => void;\n};\n\nexport type MutationFn<\n  TParams extends ParamValues | undefined = DefaultParams,\n  TOutput = DefaultOutput,\n> = (options?: MutationHookOptions<TParams, TOutput>) => void;\n\nexport type MutationState<TOutput = DefaultOutput> = {\n  /**\n   * The output of the last successfully executed task.\n   */\n  output?: TOutput;\n  /**\n   * Will be true when the task is currently executing.\n   */\n  loading?: boolean;\n  /**\n   * Will be set with the error message if the task failed to execute.\n   */\n  error?: ExecuteError;\n  /**\n   * The ID of the run.\n   */\n  runID?: string;\n};\n\nexport type MutationResult<\n  TParams extends ParamValues | undefined = DefaultParams,\n  TOutput = DefaultOutput,\n> = {\n  /**\n   * Function that executes the task mutation.\n   */\n  mutate: MutationFn<TParams, TOutput>;\n} & MutationState<TOutput>;\n\n/**\n * useTaskMutation executes a task.\n *\n * This should be used for tasks that create/update/delete data.\n */\nexport const useTaskMutation = <\n  TParams extends ParamValues | undefined = DefaultParams,\n  TOutput = DefaultOutput,\n>(\n  mutation: TaskMutation<TParams, TOutput>,\n): MutationResult<TParams, TOutput> => {\n  const fullMutation = getFullMutation<TParams>(mutation);\n  const result = useTaskOrRunbookMutation<TParams, TOutput>({\n    mutation: fullMutation,\n    type: \"TASK\",\n  });\n  switch (result.type) {\n    case \"TASK\":\n      return result.result;\n    default:\n      throw new Error(\"invalid result type\");\n  }\n};\n"],"names":["useTaskMutation","mutation","fullMutation","getFullMutation","result","useTaskOrRunbookMutation","type","Error"],"mappings":";;AA6EaA,MAAAA,kBAAkB,CAI7BC,aACqC;AAC/BC,QAAAA,eAAeC,gBAAyBF,QAAQ;AACtD,QAAMG,SAASC,yBAA2C;AAAA,IACxDJ,UAAUC;AAAAA,IACVI,MAAM;AAAA,EAAA,CACP;AACD,UAAQF,OAAOE,MAAI;AAAA,IACjB,KAAK;AACH,aAAOF,OAAOA;AAAAA,IAChB;AACQ,YAAA,IAAIG,MAAM,qBAAqB;AAAA,EACzC;AACF;"}