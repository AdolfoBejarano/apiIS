import { useQuery } from "@tanstack/react-query";
import { useState } from "react";
import { executeTaskBackground, executeTask, isExecuteTaskError } from "../../client/executeTask.js";
import { getFullQuery, getSlug } from "../../components/query.js";
const useTaskQuery = (query) => {
  const [executedRunID, setExecutedRunID] = useState();
  const fullQuery = getFullQuery(query);
  const {
    params,
    enabled: enabledOption = true,
    refetchInterval,
    allowCachedMaxAge,
    executeOnMount = true,
    executeOnWindowFocus = false,
    executeOnReconnect = true,
    onSuccess,
    onError
  } = fullQuery;
  const slug = getSlug(fullQuery);
  const enabled = Boolean(enabledOption) && Boolean(slug);
  const {
    isInitialLoading,
    isLoading,
    error,
    data,
    refetch,
    isFetching
  } = useQuery([slug, params], async () => {
    const runID = await executeTaskBackground(slug, "query", params, allowCachedMaxAge);
    if (typeof runID === "object") {
      throw runID;
    }
    setExecutedRunID(runID);
    const r = await executeTask(slug, "query", params, runID, allowCachedMaxAge);
    if (isExecuteTaskError(r)) {
      throw r;
    }
    return r;
  }, {
    enabled,
    refetchInterval,
    refetchOnMount: executeOnMount,
    refetchOnWindowFocus: executeOnWindowFocus,
    refetchOnReconnect: executeOnReconnect,
    onSuccess: (res) => {
      onSuccess == null ? void 0 : onSuccess(res.output, res.runID);
    },
    onError: (res) => {
      onError == null ? void 0 : onError(res.output, res.error, res.runID);
    }
  });
  return {
    output: (data == null ? void 0 : data.output) ?? (error == null ? void 0 : error.output),
    runID: executedRunID ?? (data == null ? void 0 : data.runID) ?? (error == null ? void 0 : error.runID),
    error: error == null ? void 0 : error.error,
    loading: enabled ? isLoading : Boolean(isInitialLoading),
    refetch,
    executing: isFetching
  };
};
export {
  useTaskQuery
};
//# sourceMappingURL=useTaskQuery.js.map
