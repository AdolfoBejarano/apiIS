{"version":3,"file":"useRouter.js","sources":["../../src/routing/useRouter.ts"],"sourcesContent":["import { useQueryClient } from \"@tanstack/react-query\";\nimport { useCallback, useEffect, useState } from \"react\";\n\nimport { TASKS_GET_METADATA, VIEWS_GET, WEB_HOST_GET } from \"client/endpoints\";\nimport { AIRPLANE_ENV_SLUG } from \"client/env\";\nimport { Fetcher } from \"client/fetcher\";\nimport { TaskMetadata, View } from \"client/types\";\nimport { sendViewMessage } from \"message/sendViewMessage\";\n\nexport type NavigateParams = {\n  /** A view slug to navigate to. */\n  view?: string;\n  /** A task slug to navigate to. */\n  task?: string;\n  /** A runID to navigate to. */\n  runID?: string;\n  /** Optional params to pass through to the navigated route. */\n  params?: Record<string, string | undefined>;\n};\n\ntype PeekParamsBase = {\n  /** Optional params to pass through to the peek. */\n  params?: Record<string, string | undefined>;\n  /**\n   * Way of opening the peek.\n   * @default \"side_peek\"\n   */\n  as?: \"center_peek\" | \"side_peek\";\n};\n\ntype TaskPeekParams = {\n  /** A task slug to open in a peek. **/\n  task: string;\n} & PeekParamsBase;\n\ntype ViewPeekParams = {\n  /** A view slug to open in a peek. **/\n  view: string;\n} & PeekParamsBase;\n\ntype RunbookPeekParams = {\n  /** A runbook slug to open in a peek. **/\n  runbook: string;\n} & PeekParamsBase;\n\ntype PagePeekParams = {\n  /** A page path to open in a peek. **/\n  page: string;\n} & PeekParamsBase;\n\ntype PeekParams =\n  | TaskPeekParams\n  | ViewPeekParams\n  | RunbookPeekParams\n  | PagePeekParams;\n\nexport type Router = {\n  /** The parameters passed to this view. */\n  params: Record<string, string | undefined>;\n  /** Navigate to another task or view */\n  navigate: (params: NavigateParams) => Promise<void>;\n  /** Get a href string that navigates to another task or view */\n  getHref: (params: NavigateParams) => Promise<string>;\n  peek: (params: PeekParams) => void;\n};\n\nexport const useRouter = (): Router => {\n  const queryClient = useQueryClient();\n  const viewParams = useQueryParamsFromHash();\n\n  const getViewURL = useCallback(\n    async (viewSlug: string, queryParams?: URLSearchParams) => {\n      const fetcher = new Fetcher();\n      const [viewData, webHost] = await Promise.all([\n        queryClient.fetchQuery([VIEWS_GET, viewSlug], async () => {\n          return await fetcher.get<View>(VIEWS_GET, {\n            slug: viewSlug,\n          });\n        }),\n        queryClient.fetchQuery([WEB_HOST_GET], async () => {\n          return await fetcher.get<string>(WEB_HOST_GET, {});\n        }),\n      ]);\n\n      if (queryParams === undefined) {\n        queryParams = new URLSearchParams();\n      }\n      if (viewData?.isLocal) {\n        const studioQueryParams = new URLSearchParams(queryParams);\n        studioQueryParams.append(\"view\", viewSlug);\n        return `${webHost}/studio?${studioQueryParams}`;\n      }\n      return `${webHost}/views/${viewData.id}?${queryParams}`;\n    },\n    [queryClient],\n  );\n\n  const getTaskURL = useCallback(\n    async (taskSlug: string, queryParams?: URLSearchParams) => {\n      const fetcher = new Fetcher();\n      const [taskMetadata, webHost] = await Promise.all([\n        queryClient.fetchQuery([TASKS_GET_METADATA, taskSlug], async () => {\n          return await fetcher.get<TaskMetadata>(TASKS_GET_METADATA, {\n            slug: taskSlug,\n          });\n        }),\n        queryClient.fetchQuery([WEB_HOST_GET], async () => {\n          return await fetcher.get<string>(WEB_HOST_GET, {});\n        }),\n      ]);\n      if (queryParams === undefined) {\n        queryParams = new URLSearchParams();\n      }\n      if (taskMetadata?.isLocal) {\n        const studioQueryParams = new URLSearchParams(queryParams);\n        studioQueryParams.append(\"task\", taskSlug);\n        return `${webHost}/studio?${studioQueryParams}`;\n      }\n      return `${webHost}/tasks/${taskMetadata.id}?${queryParams}`;\n    },\n    [queryClient],\n  );\n\n  const getRunURL = useCallback(\n    async (runID: string, queryParams?: URLSearchParams) => {\n      const fetcher = new Fetcher();\n      const webHost = await queryClient.fetchQuery([WEB_HOST_GET], async () => {\n        return await fetcher.get<string>(WEB_HOST_GET, {});\n      });\n      if (queryParams === undefined) {\n        queryParams = new URLSearchParams();\n      }\n      // TODO: VIEW-692 query API for local or remote run instead of looking at run ID\n      if (isLocalDevRunID(runID)) {\n        const studioQueryParams = new URLSearchParams(queryParams);\n        studioQueryParams.append(\"run\", runID);\n        return `${webHost}/studio?${studioQueryParams}`;\n      } else if (isRemoteRunID(runID)) {\n        return `${webHost}/runs/${runID}?${queryParams}`;\n      } else throw new Error(\"Run ID is not local or remote.\");\n    },\n    [queryClient],\n  );\n\n  const getHref: Router[\"getHref\"] = useCallback(\n    ({ view, task, runID, params }) => {\n      const queryParams = new URLSearchParams(coerceParamsType(params));\n      if (AIRPLANE_ENV_SLUG) {\n        queryParams.append(\"__env\", AIRPLANE_ENV_SLUG);\n      }\n\n      propagateQueryParam(queryParams, \"__airplane_host\");\n      propagateQueryParam(queryParams, \"__airplane_tunnel_token\");\n      propagateQueryParam(queryParams, \"__airplane_sandbox_token\");\n\n      const count = [view, task, runID].filter(Boolean).length;\n      if (count > 1) {\n        throw new Error(\"Only one of view, task, or runID can be set\");\n      }\n\n      if (view) {\n        return getViewURL(view, queryParams);\n      } else if (task) {\n        return getTaskURL(task, queryParams);\n      } else if (runID) {\n        return getRunURL(runID, queryParams);\n      } else {\n        // Note: we encode the view's query params in the hash so the cache for the view is not busted in web.\n        return Promise.resolve(`/#${queryParams}`);\n      }\n    },\n    [getTaskURL, getViewURL, getRunURL],\n  );\n\n  const navigate: Router[\"navigate\"] = useCallback(\n    ({ view, task, runID, params }) => {\n      if (typeof window === \"undefined\" || !window.top) {\n        return Promise.resolve();\n      }\n\n      const nav = async () => {\n        if (view || task || runID) {\n          window.top!.location.href = await getHref({\n            view,\n            task,\n            runID,\n            params,\n          });\n        } else if (inIframe()) {\n          sendViewMessage({\n            type: \"update_query_params\",\n            params: coerceParamsType(params),\n          });\n        } else {\n          window.history.pushState(\n            {},\n            \"\",\n            await getHref({\n              params,\n            }),\n          );\n          // pushState doesn't cause a hashchange event to be fired, so we do it manually.\n          window.dispatchEvent(new HashChangeEvent(\"hashchange\"));\n        }\n      };\n\n      return nav();\n    },\n    [getHref],\n  );\n\n  const peek: Router[\"peek\"] = useCallback((peekParams) => {\n    if (inIframe()) {\n      if (\"view\" in peekParams && peekParams.view) {\n        sendViewMessage({\n          type: \"peek\",\n          peekType: \"view\",\n          slug: peekParams.view,\n          params: peekParams.params,\n          as: peekParams.as,\n        });\n      } else if (\"task\" in peekParams && peekParams.task) {\n        sendViewMessage({\n          type: \"peek\",\n          peekType: \"task\",\n          slug: peekParams.task,\n          params: peekParams.params,\n          as: peekParams.as,\n        });\n      } else if (\"runbook\" in peekParams && peekParams.runbook) {\n        sendViewMessage({\n          type: \"peek\",\n          peekType: \"runbook\",\n          slug: peekParams.runbook,\n          params: peekParams.params,\n          as: peekParams.as,\n        });\n      } else if (\"page\" in peekParams && peekParams.page) {\n        sendViewMessage({\n          type: \"peek\",\n          peekType: \"page\",\n          slug: peekParams.page,\n          params: peekParams.params,\n          as: peekParams.as,\n        });\n      } else {\n        throw new Error(\"Must specify task, view, runbook, or page\");\n      }\n    }\n  }, []);\n\n  return {\n    params: Object.fromEntries(viewParams),\n    navigate,\n    getHref,\n    peek,\n  };\n};\n\n/**\n * coerceParamsType coerces the params to be a stricter Record type.\n */\nconst coerceParamsType = (\n  params: Record<string, string | undefined> | undefined,\n): Record<string, string> | undefined => {\n  if (params) {\n    const filteredParams: Record<string, string> = {};\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        filteredParams[key] = value;\n      }\n    });\n    return filteredParams;\n  }\n  return params;\n};\n\n/**\n * useQueryParamsFromHash is a hook that reads and returns the query params from the URL hash.\n *\n * Note: we encode the view's query params in the hash so the cache for the view is not busted in web.\n */\nconst useQueryParamsFromHash = () => {\n  let initialViewParams: URLSearchParams;\n  if (typeof window === \"undefined\") {\n    initialViewParams = new URLSearchParams();\n  } else {\n    initialViewParams = new URLSearchParams(getParamsStringFromHash());\n  }\n  const [viewParams, setViewParams] = useState(\n    new URLSearchParams(initialViewParams),\n  );\n\n  useEffect(() => {\n    const handleHashChange = () => {\n      setViewParams(new URLSearchParams(getParamsStringFromHash()));\n    };\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => {\n      window.removeEventListener(\"hashchange\", handleHashChange);\n    };\n  }, []);\n  return viewParams;\n};\n\n// See https://stackoverflow.com/a/326076\nfunction inIframe() {\n  try {\n    return window.self !== window.top;\n  } catch (e) {\n    return true;\n  }\n}\n\nconst getParamsStringFromHash = () => {\n  // Remove the leading '#'\n  return window.location.hash?.slice(1);\n};\n\nexport const isLocalDevRunID = (runID: string) => {\n  return runID.startsWith(\"devrun\");\n};\n\nexport const isRemoteRunID = (runID: string) => {\n  return runID.startsWith(\"run\");\n};\n\n// propagateQueryParam appends the value of a query param from the current URL to the given query\n// params, if it exists.\nconst propagateQueryParam = (queryParams: URLSearchParams, key: string) => {\n  const value =\n    window !== undefined\n      ? new URLSearchParams(window.location.search).get(key)\n      : undefined;\n  if (value) {\n    queryParams.append(key, value);\n  }\n};\n"],"names":["useRouter","queryClient","useQueryClient","viewParams","useQueryParamsFromHash","getViewURL","useCallback","viewSlug","queryParams","fetcher","Fetcher","viewData","webHost","Promise","all","fetchQuery","VIEWS_GET","get","slug","WEB_HOST_GET","undefined","URLSearchParams","isLocal","studioQueryParams","append","id","getTaskURL","taskSlug","taskMetadata","TASKS_GET_METADATA","getRunURL","runID","isLocalDevRunID","isRemoteRunID","Error","getHref","view","task","params","coerceParamsType","AIRPLANE_ENV_SLUG","propagateQueryParam","count","filter","Boolean","length","resolve","navigate","window","top","nav","location","href","inIframe","type","history","pushState","dispatchEvent","HashChangeEvent","peek","peekParams","peekType","as","runbook","page","Object","fromEntries","filteredParams","entries","forEach","key","value","initialViewParams","getParamsStringFromHash","setViewParams","useState","useEffect","handleHashChange","addEventListener","removeEventListener","self","e","hash","slice","startsWith","search"],"mappings":"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"}